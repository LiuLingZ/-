

https://blog.csdn.net/u013679744/article/details/79188945#commentBox

# 一、引言

### 1、引入

前面提到的CAP和BASE，是分布式系统设计的基础理论，讲到一个最终一致性，其实也就是分布式系统要解决的一个重要问题，分布式一致性问题，由此出现了很多**一致性协议**，这里就介绍两个比较常见的有：（Phase submission）

​	**两阶段提交（2PC）**

​	**三阶段提交（3PC）**

这里的一致性不是指数据的一致性，因为数据诸如mysql\redis的主从、集群都是异步同步的，本身不是强一致性，这里的一致性应该理解为使系统达到BASE状态，确保分布式系统正确运行。

**2pc \ 3pc 就是解决分布式事务（参与事务的管理器可能不在同一个节点上）的原子性、一致性问题。**



### 2、分布式事务问题

​	在单个节点中，一个节点的事务可以满足ACID，但是如果涉及多个节点，节点间由于需要通过网络进行传输，那么，可能存在，A节点的事务执行成功，但是B节点的失败回滚了，然而A是不知道B是否成功，这就导致了AB两状态的不同，这个时候，需要一个**中间“协调者”的组件来统筹所有节点的事务执行状态，分布式的节点应该是要么全部成功，要么全部失败**。

​	而二阶段提交保证的就是全局服务器的事务的原子性，要么全做要么全不做。





# 二、详解



## 2PC



### 1、概述

两阶段提交：准备阶段（投票阶段） 、提交阶段

```java
- 2pc 两阶段提交有两种身份，事务参与者和事务协调者
- 事务参与者是分布式事务的事务执行服务器，协调者是协调这些服务器的组件。
- 2pc解决了分布式事务的原子性，所谓两阶段提交，第一阶段是准备阶段（投票阶段）；第二阶段提交阶段。
```



### 2、过程

第一阶段：准备阶段

- 事务协调者（事务管理器）给每个事务参与者发送消息    

- 事务参与者接收到请求后各自执行事务，写undo文件和redo文件，执行结束后不提交，而是返回执行状态反馈给事务协    调者，YES or No .

第二阶段：提交阶段

- 事务协调者收到事务参与者反馈的状态，如果都是成功，则发送“正式提交”的请求给每个事务参与者，完成最终提交。如果收到了失败状态，则发消息给所有的参与者，所有参与者回滚。
- 不论成功还是失败，最终都释放事务占用的资源，第二阶段就此结束。

![img](https://img-blog.csdn.net/20180131153947821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzY3OTc0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

![img](https://img-blog.csdn.net/20180131154221939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzY3OTc0NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



**ps：当协调者与参与者的沟通，任一方发生超时时，直接回滚。不论如何，第二阶段之后事务就结束了。二阶段提交能保证分布式事务的原子性**



### 3、2pc的优缺点

```
优点：
- 简单，直观。大多数关系型数据库都可以用2pc来完成分布式事务处理。

缺点：
- 同步阻塞问题：进行2pc分布式事务时，所有参与者都要占有事务所需的资源，那么其他请求如果需要访问这些资源，就   需要等到这些参与者在第二阶段释放资源后才能访问，否则只能阻塞。
- 单点故障：可以看出事务协调者的重要性，如果崩了，并且只有一台事务参与者，事务参与者还在发送事务提交结果的 
  ACK之后也崩了，那么就没人知道现在事务的状态了，即使热备换上来的事务协调者也不知道，这是比较极端的情况。
- 过于保守：但凡超时、或者任意机子宕机，就回滚，代价不小。
- 有个问题，就是有个事务参与者在commit之后宕机了，没有回复给事务协调者，导致事务协调者只能回滚其他事务，而这个宕机的实际上已经持久化进去了，那么就导致了数据的不一致性。
```







## 3PC

### 1、概述

```
- 基于2PC同步阻塞、单点、数据不一致（第二步直接提交可能不一致）的问题，出现了3PC，即 三阶段提交 。
- 三阶段提交将准备阶段一分为二，所以总的过程有 
  CanCommit 、PreCommit 、DoCommit
  （三阶段相比两阶段，中间多了个预提交，用来避免直接提交导致的可能失败）
- 相比较于2pc，3pc引入了超时机制：到了docommit时，超时自动提交。（2pc哪个时候都是超时回滚）
```



### 2、过程

#### CanCommit

​	该阶段和2pc的准备阶段很像，有点不同的是，3pc是事务协调者发消息询问事务参与者判断**自己能否顺利执行事务，根据此返回消息给事务协调者。**（是否能执行，2pc是直接执行）

#### PreCommit

​	事务协调者根据事务参与者返回的状态，决定是否继续事务，如果可以发送继续执行事务的消息。

​	事务参与者收到消息后，就开始执行自己的事务逻辑，暂不提交，写入undo和redo文件中后返回ACK响应。等待最终的指令。

​	如果在这个阶段有参与者返回no，即不能完成事务，或者返回的响应超时，则事务协调者就会给所有事务参与者发abort指令，中断事务，回滚。



#### doCommit

​	到了这个阶段，就是真正提交事务了。

​	当事务协调者收到所有ack后，就可以发送docommit指令，要求所有参与者提交事务。

​	参与者在收到请求后提交事务，并且释放资源。同时响应事务协调者，发送ACK请求。

​	事务协调者收到所有事务参与者的ack后，完成事务。



注：在doCommit阶段，即使没有收到部分ack，或者说是网络超时，也默认提交，而不是2pc的回滚，因为根据经验来看，到了doCommit阶段，很大概率是能成功提交的。

​	

#### 3、优缺点

```
优点：相比2pc，降低了一定的同步阻塞问题，到了第三阶段，基本就可以开始自行接收请求了，默认commit事务。
缺点：
- 还是比较保守的，12阶段的超时都是回滚。对于同步阻塞问题还是存在的。
- 数据不一致问题，如果doCommit阶段，事务协调者出了意外想要abort事务，即要回滚事务，但是有的事务参与者出于网   络等原因收不到，默认提交了事务，那就导致事务不一致了。
```







基于消息的最终一致性

​	强一致性 是最大的优点。（下一个服务必须等上一个服务执行ok，发消息到消息队列，队列再提醒下一个服务，同时回调通知上一个服务关于下一个服务执行的结果。）

​	浪费资源（一个业务要等另外一个业务执行结果，来确定是否commit或rollback）



TCC补偿

​	各个业务可以并行执行

​	补偿指，如果需要回滚，在Cancel阶段反向执行Try即可。

​	比如try扣了5个库存，那么cancel加回5个即可。

​	相比之下，不会强一致性，比较缓和，效率高些。







分布式事务中，是通过抛出异常确认某个服务是否失败，所以不要轻易在业务服务中捕获异常，否则无法保证事务。

TCC-Transaction的confirm 和 cancel 都需要自己代码去支持幂等性。 

幂等性：一个接口被多次调用和一次调用，结果是相同的。

