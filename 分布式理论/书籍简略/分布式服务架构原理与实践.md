# 第三章	通信架构（基于Netty）

## 	3.1关键点分析

### 		3.1.1 使用长连接

### 		3.1.2使用NIO，大多分布式架构的RPC选用Netty

## 	3.2功能研究

### 		3.2.1 通过Netty实现

## 	3.3可靠性设计

### 		3.3.1 链路有效性检测

​			心跳检测（TCP层、协议层、应用层）

### 		3.3.2 断连重连机制

### 		3.3.3消息缓存重发

### 		3.3.4资源优雅释放

​			Netty提供了

## 	3.4性能设计

### 		3.4.1性能差三个瓶颈

​			网络传输方式问题（传统RPC是BIO）

​			序列化性能差（Java只支持自身的序列化，通用性低；序列化后码流太大；序列化性能差，占CPU）

​			线程模型问题（BIO，一个TCP占一个线程；JVM很宝贵）

### 		3.4.2通信新能三原则

​			传输

​			协议

​			线程

### 		3.4.3高性能之道（Netty提供）

​			异步非阻塞，多路复用

​			高效的I/O线程模型：Netty支持 Reactor单（多）线程模型、主从Reactor多线程模型

​			高性能的序列化框架			

## 	3.5最佳实践

​		误区1：不指定线程池大小，不要用系统默认的

​		误区2：I/O线程池使用不当，导致通信线程膨胀。（预评估、hash法减少碰撞）



# 第四章	序列化与反序列化（JSON/Protobuf）

## 4.1 概念

​	序列化：编码，将对象序列化为字节数组，用于网络传输、数据持久化或其他用途

​	反序列化：解码，将字节数组还原为对象。

​	**序列化与反序列给远程调用**

### 	4.1.1 序列化与通信架构 

​		序列化和通信框架非强耦合，而是单独的服务，非通信框架的功能

### 	4.1.2序列化与通信协议 

​		相互解耦，序列化可以选用多种协议，反之也可，如HHTP可以传XML、JSON

### 	4.1.3是否要支持多种序列化方式

​		由于序列化框架是单独的服务，很灵活，可按需扩展

## 4.2 功能设计

### 	4.2.1 功能丰富度

​		支持多少张数据类型、使用起来是否简便

### 	4.2.2 跨语言支持

### 	4.2.3 兼容性（向前兼容）

​		接口兼容性 ：老接口仅需数据中的一部分，新数据可以提供老的。新的数据，老接口可以不接受

​		业务的逻辑兼容

​		数据兼容性

​		**接口的兼容性，数据的改变，不需要旧的接口，自动获取自己所需的数据部分。**

### 	4.2.4 性能

​		三个指标：序列化后**码流大小** 、 序列化/反序列化的 **速度** 、**资源占用**（耗能）

​	

##   4.3扩展设计

### 	 4.3.1 Netty内置 [反]序列化

##   4.4 最佳实践

### 	4.4.1 接口向前兼容性规范

​		分布式框架，需要先做： 制定兼容性规范（怎么处理新的和自己想要的） ； 

### 	4.4.2 高并发下的稳定性

​		对序列化框架模拟高压，提前发现问题。





# 第五章	协议栈

​	不同服务在性能上适用不同协议进行传输



# 第六章	服务路由

​	分布式系统都是服务集群的多实例部署，消费者如何从服务列表中选出一个最合适的服务者进行访问，这涉及到服务路由。分布式服务框架需要满足灵活的路由需求。

## 6.1透明化路由

​	不需要在消费者中硬编码、或者访问配置文件，消费者不需要感知到路由存在。才算透明！

### 	6.1.1基于服务注册中心的订阅发布（eg：Zookeeper）

​		服务者注册到注册中心。注册中心保留着服务者的信息列表，消费者主动订阅或者被动通知感知到服务者位置。服务者一旦有变，注册中心就会推送信息给消费者告知情况。消费者会缓存服务者信息

##  6.2 负载均衡

​	分布式服务框架通常提供多种负载均衡策略，支持扩展

### 	6.2.1 随机 

​		碰撞率高、不均衡

### 	6.2.2 轮询

​		按公约权重，每台都负载那么多，一台满了再到下一台

​		缺点：有的机器性能没那么好，请求可能一直卡在某台动不了

### 	6.2.3 服务调用时延	

### 	6.2.4 一致性哈希

### 	6.2.5 粘滞连接

​	

##  6.3 本地路由优先策略

### 	 6.3.1 injvm模式

​		一个JVM中的某个服务也需要消费，那么他优先调用自己JVM提供的服务提供者，这种本地优先的路由模式称

​		为injvm模式。



## 6.4路由规则

​	一些场景需要对路由策略设置过滤条件，比较常见的是基于表达式 的条件路由和脚本路由

### 	6.4.1 条件路由策略

​		通过IP条件表达式的黑白名单访问控制

​		流量引导：只暴露部分服务提供者，防止整个集群服务都被冲垮

​		读写分离

​		前后台分离

​		灰度升级：将web前台应用 路由到 新的服务版本上

### 	6.4.2 脚本路由规则

​		**脚本路由规则特点是 支持动态编译，修改后实时生效，不需重启系统，在线上动态调整路由规则十分有效。**

## 6.5路由策略定制

​	平台除了默认的路由策略外，在架构上还支持业务扩展路由算法，实现业务自定义路由。

## 6.6 配置化路由

​	路由配置策略如下：	

​		本地配置：包括服务提供者、服务消费者、默认全局配置三种。

​		统一注册管理：本地配置的路由策略 统一注册 到服务注册中心，进行集中化配置管理

​		动态下发

​		路由配置优先级：客户端配置＞服务端配置＞全局配置



## 6.7 最佳实践——多机房路由

​	

# 第7章	集群容错

​	集群服务调用失败后，服务框架需要在底层自动容错。容错策略很多，使用不同的场景。

## 7.1 集群容错场景

分布式服务框架中，消费者调用请求，对服务提供者的信息、位置是完全不知的。调用通过服务路由去转发，消费者只关心调用是否成功。但是服务调用可能出错。

### 	7.1.1 通信链路故障	

​		这里是消费者和服务生产者之间的链路，一般是长连接

### 	7.1.2 服务端超时

​		IO阻塞、业务处理慢、发生Full GC长时中断。

### 	7.1.3 服务端调用失败

​		在服务端这边发生了错误

## 7.2 容错策略

​	服务不同，容灾策略不同

### 	7.2.1 失败自动切换 （Failover） 

​		指RPC调用异常时，重新选路，查找下一个可用的服务提供者。

### 	7.2.2 失败通知（Failback） 

### 	7.2.3 失败缓存 （Failcache）

​		当服务链路中断、流控等服务暂不可用时，将请求缓存起来，等待一段时间后重新发送。

​		如果不敏感的服务，可以考虑慢时的自动恢复模式，即先缓存，再等待，最后重试。

### 	7.2.4 快速失败（Failfast）

​		发生异常，忽略异常，记录异常，直接返回失败. 对资源不敏感可用.

### 	7.2.5 容错策略扩展

​		总有不适用原有处理方案的错误.需要指错容错接口的扩展、屏蔽细节之类





# 第八章	服务调用

## 8.1 几个误区

​	服务调用和MVC的调用思想是不同的。

### 	8.1.1 误区一：NIO 就是异步服务（NIO是同步非阻塞的）

### 	8.1.2 误区二：服务调用天生是同步的

​		服务调用主要有两种模式：OneWay模式（只有请求没有应答）、请求-应答模式

​		OneWay 容易设计成异步的 。 

​		请求-应答也可以设计为异步的，难度大些而已。

### 	8.1.3 误区三： 异步服务调用性能更高 



## 8.2 服务调用方式

### 	8.2.1 同步服务调用

​		客户端远端调用请求 → 用户线程完成消息序列化后，将消息投递到通信框架 → 同步阻塞 → 等待通信线程发送请求并接受到应答 → 唤醒等待的用户线程 → 用户线程取得应答后放回。 

### 	8.2.2 异步服务调用

​		基于JDK的Future，方便实现异步服务调用 。 Netty本身也提供了异步Future

### 	8.2.3 并行服务调用

​		服务间不存在相互依赖关系，可以采用并行。

​		长流程，无关联部分可以并行。

​	**要解决串行调用效率低的问题，可以** **：** **异步服务调用、并行服务调用**



## 8.3 最佳实践

​	降低业务E2E时延

​	可靠性角度

​	业务场景

​	传统的RPC调用

​	

# 第9章 服务注册中心

​	有效管理服务的订阅、发布，避免硬编码地址信息。

## 9.1 几个概念

### 	9.1.3 服务注册中心	

​	服务注册中心：分布式服务框架的目录服务器，相比传统的目录服务器，有特点：

​		高HA：支持数据持久化、集群

​		数据一致性问题

​		数据变更主动推送

## 9.3 基于Zookeeper的服务注册中心设计

​	Zookeeper ，主要用来解决分布式 应用中经常遇到的一些数据管理问题，如统一命名服务、状态同步服务、集群管理、分布式应用统一配置等。

### 	9.3.1 服务订阅发布流程设计

### 	9.3.2 服务健康状态监测 （自动下线不可用）

### 	9.3.3 对等集群防止单点故障

### 	9.3.4 变更通知机制

​		Zookeeper中的服务目录节点信息有变化，集群中的每个消费者实例都会收到Zookeeper的通知。让后从Zookeeper中获取新的服务注册信息到系统中。



## 9.4 总结

​	分布式服务框架需要一个 服务注册中心 实现服务的订阅、发布、服务动态发现 和 透明化路由 。

实现分布式服务框架的技术方案很多，如 ZooKeeper ，



# 第十章	服务发布和引用

​	服务提供者需要支持 通过配置、 注解、 API调用等方式，把 本地接口 发布成远程接口 ； 对于消费者，可以通过对等的方式引用远程服务提供者，实现服务的发布和引用。

## 10.1 服务发布设计

### 	10.1.1 服务发布的几种方式

​	XML配置化方式 （建议）

​	注解方式

​	API调用方式

### 	10.1.2 本地实现类封装成代理

​		服务的发布引用都是封装成代理，屏蔽底层不同

### 	10.1.3 服务发布成指定协议

### 	10.1.4 服务提供者注册信息



## 10.2 服务引用设计

### 	10.2.1 本地接口调用转换成远程服务调用

### 	10.2.2 服务地址本地缓存

### 	10.2.3 远程服务调用

## 10.3 最佳实践

### 	10.3.1 对等设计原则

​		如果服务框架打算支持多种服务发布形式，各种服务发布形式提供的功能应该是对等的，不能特殊形式多了或少了服务内容。

### 	10.3.2 启动顺序问题

### 	10.3.3 同步还是异步发布服务

### 	10.3.4 警惕网络风暴

### 	10.3.5 配置扩展

## 10.4 总结

​	一个好的分布式服务框架对业务代码的侵入要足够低，如通过XML配置化的方式将普通的Java接口发布成远程服务； 消费者通过配置化的方式引用服务提供的接口。

​	基于接口编程，服务框架底层无论如何变都不会影响上层服务应用，真正实现业务和平台解耦。



# 第十一章	服务灰度发布

​	灰度发布指 在黑与白之间，能够平滑过渡的一种发布方式。 AB test 就是一种灰度发布方式。让一部分用户使用A， 一部分开始使用B 。 当B 使用没毛病，就逐步扩大使用范围，最终全部使用B。

# 第十二章	参数传递

## 12.1 内部传参

​	指 服务提供者 或消费者接口 内部业务上下文信息的传递，主要包括：

​	业务内部参数传递、服务框架和业务间的参数传递。

## 12.2 外部传参

​	主要用于服务消费者 和 服务提供者 之间进行参数传递，主要包括：

​	服务框架自身的参数传递，日分布式事务的事务上下文信息传递

​	业务之间的参数传递，如业务调用链ID的传递，用于唯一标识某个完整的业务流程

## 12.3 最佳实践

### 	12.3.1 防止参数互相覆盖	

### 	12.3.2 参数生命周期管理

# 第十三章	服务多版本

## 13.1 服务多版本管理设计

​	服务多版本管理对象包括：服务提供者 和 消费者

​	服务提供者：发布服务的时候，支持指定服务的版本号

​	服务消费者：消费服务的时候，支持指定引用的服务版本号 或者 版本范围



















