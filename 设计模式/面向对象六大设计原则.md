面向对象的六大原则主要的目的，就是我们如何设计类，能更好的利用面向对象的特性。

# 一、开闭原则

### 	关键：扩展开放，修改封闭

类一旦确定，就不应该再对其功能发生修改。这是面向对象设计中，最重要最核心的原则。方案发布后，我们最担心的是什么？就是需求的变化，而需求一旦有变化，就要修改代码。大部分的bug往往就是这时候引入的。因为修改代码时，我们往往将重点放在，如何解决当前bug上，反而没有注意因为这个修改，对原有设计的影响。

```java
理解：抽象构建框架，实现扩展细节。
```





# 二、单一职责原则

### 	关键：一个类永远只有一个职责。

​	例如传统的Java Web中，一个UserService类，就应该只含关乎User操作的功能，不含其它附加功能。类就要各司其职，分工明确。如果类之间的功能出现了混淆，那么软件的整体结构就会非常的混乱。就像管理学中的一句话，如果一个职责由每个员工负责，那么这个职责就没有员工在负责。 这个原则的概念非常简单，也是非常基础的。

```java
理解：一个类中一个方法的修改如果导致另外一个方法不可用，应该将这两个方法拆分为两个类。
```



​	

# 三、里氏替换原则

### 	关键：子类继承父类后因尽可能保留父类实现的方法。

​	 这个原则主要是为了体现面向对象的“继承”特征来提出的。 它的主旨就是，能够使用基类的地方，必然也能够透明的使用其子类，并且保证不会出错。为了保证这种透明的无差别的使用，子类在使用时不应该随意的重写父类已经定义好的非抽象的方法。因为这些非抽象方法，类似于某种职能或契约，当父类保持这种约定时，子类也应该遵循并保证该特性，而非修改该特性。 我们在写代码的时候，如果一个参数设定的是基类（或接口、抽象类），那么我们传送子类进去，一样可以正常使用。因为基类相对于父类，只是一个更丰富，更具体，更详细的表现形式。而不应该出现，传入父类运行某种方法没有问题，可是传入子类运行时就报错了。

​	Ps ： 为什么要叫里氏替换原则呢？这是因为最早提出这个理论的人姓里Liskov。这是计算机中少有的以姓氏命名的东西。

```java
理解：使用父类的地方都能透明的使用子类，原行为不变。
```









# 四、最少知道原则

### 	关键：一个类应该少依赖其它类，否则类的关系会变复杂，牵一发动全身

​	我们在学习编程的初期，都会有人告诉我们要遵循“高内聚，低耦合”。而OO中也将“封装”作为对象的基本特征之一。最少知道原则其实体现的就是“高内聚，低耦合”这句话。

（1）低耦合：一个类对于自己依赖的类，知道的越少越好。不要让一个类依赖过多的类。否则这个类很容受外界的影响，并且因为这种影响要改变自身的代码（自身要适应）。

（2）高内聚：将实现逻辑都封装在类的内部，对public方法以外的信息，不轻易暴露给外界。这是由于public对外后，相当于是一种契约，一种许诺。你要再后边的实现中，不断的去兼容这种public，以防止调用它的代码不会报错。 上面这样说，可能有点抽象，这里举个例子。在很多人对另一方的要求，都有一条，社会关系不要复杂。为什么会这样呢？因为一个人如果他和外界的关系越复杂，他就越不稳定，不怕人找事，就怕事找人。或许他的本性是好的，但是周边的龙鱼混杂，三天两头的总会有事。避免这种问题的最好办法，就是一开始就做一个安静的美男子。  

```java
理解：类与类之间的依赖越少越好，才能低耦合。
```





# 五、接口隔离原则

### 	关键：一个类对于另外一个类的依赖应该建立在最小的接口上。

​	一个接口定义的过于臃肿，则代表他的每一个实现类都要考虑所有的实现逻辑。如果一个类实现了某个接口，也就是说这个类承载了这个接口所有的功能，维护这些功能成为了自己的职责。这就无形中增加了一个类的负担。

这里有两点需要说明一下：

（1）接口定义的小，但是要有限度。对接口细化可以增加灵活性，但是过度细化则会使设计复杂化。同时接口的使用率不高，提高了代码的维护成本。这种极端的体现就是每个接口只含有一个方法，这显然是不合适的。

（2）接口隔离原则和单一原则的区别

共同点：都是尽可能的缩小涉及的范围。

不同点：单一原则主要是指封装性。他针对的是一个类、一个方法，是从对象的角度考虑的。而接口隔离原则是指类之间的耦合应该保持的一个度。他针对的是类（对象）和类（对象）之间的关系。如果说单一原则指的是思想单纯，那么接口隔离指的就是社会关系简单啦。

```java
理解：类应该只实现自己所需功能的接口，不应该额外实现其他功能。
```







# 六、依赖置换原则

关键：①高层模块（如一些功能主干类，要调ABCD）不应该依赖底层模块（普通的ABCD类）。两者都应该依赖抽象 。②抽象不应该依赖细节，细节应该依赖抽象。③ 依赖倒置中心是面向接口编程。

​	这两句话的含义是：高层模块不应该依赖底层模块。两者应该通过抽象的东西进行关系链接（抽象的东西是指接口或者抽象类）。其次抽象类或者一个接口不应该依赖某个实现类。而这些实现类反而应该依赖于这个抽象类的设定。

通俗一点的说法就是，模块之间不应该直接产生调用关系（这是旧有的调用关系），两者应该通过面向接口（或者理解为面向设定的契约）进行编程。而这些契约和接口更不应该以来自底层模块而设定。这些底层模块反而应该遵守这些契约。因为契约（抽象类、接口）相对于哪些实现代码，更不会改变，也就是更稳定。所以依赖置换原则又叫作面向接口编程或面向契约编程。本意就是调整原来的依赖关系，重行进行了设定。  

eg : Spring 的 IOC中，在Service中，一般都是定义某个服务的接口，然后通过IOC注入。这就是细节依赖抽象。

```java
理解：抽象不应该依赖细节，细节应该依赖抽象。比如一个类的成员变量，应该是一个抽象类、接口的类型
```





