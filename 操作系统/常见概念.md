

https://blog.csdn.net/xiongluo0628/article/details/81461053

http://m.nowcoder.com/discuss/62723?headNav=www

## 一、进程与线程的关系以及区别

​	从粒度、资源占用、开销分析。



进程是一系列指令数据的集合，是系统分配资源和调度的基本单位。而进程可以含有多个线程，多个线程共享一个进程的内存空间，并且拥有自己线程栈，进程的执行实际是调度多个线程协调执行。线程是最小的执行单位。



### 1、定义

进程：是具备独立运行功能的程序，拥有属于自己的内存空间和资源。一个进程包含多个线程。

线程：线程是进程的一个实体，不能独立存在，线程间共享进程的资源。是最小的具备独立运行能力的基本单位。线程可以看做是轻量级进程。

### 2、关系

一个进程可以创建多个线程，多个线程可以在一个进程中并发执行。

### 3、区别

粒度上：线程远小于进程。

资源上：线程间共享进程的资源，进程是资源拥有的基本单位。

开销上：进程是巨大的，进程间执行、切换开销大，线程小很多。

![img](https://img-blog.csdn.net/20180807102459192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25nbHVvMDYyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 
简单来记： 
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 
4. 优缺点： 
  线程开销小，但不利于资源的管理和保护；进程与之相反。





## 二、Windows下的内存管理

1、虚拟内存

​	最适合用来管理大型对象或数据结构。

2、内存映射文件

​	最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据 。

3、内存堆栈

​	最适合用来管理大量的小对象。













## 三、内核态和用户态



### 内核态

```
- 当一个任务执行系统调用陷入内核代码中执行时，称进程进入了内核运行态（简称内核态）
- 内核态中，处理器处于特权级别最高的 0级 内核代码中。
- 进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。
```



### 用户态

```
- 进程在执行用户自己的代码时，称其处于用户运行态（用户态）.
- 用户态，处理器处于特权级最低的（3级）用户代码中运行。
- 用户态时，如果正在执行的用户程序突然被中断程序中断，此时用户程序也可象征性称为处于进程的内核态。因为中断处理程序使用当前进程的内核栈。这雨处于内核态的进程的状态类似。
```



### 区别、小结

```
- 用户态和内核态时OS的两种运行级别，和CPU没有必然联系。
- intel cpu提供Ring0-Ring3三种级别的运行模式。0最高，3最低。
- 没有使用Ring1和Ring2 。 Ring3不能访问Ring0的地址空间，包括代码和数据。

- Linux进程的4GB地址空间， 3G-4G部分是共享的，是内核的地址空间，存整个内核的代码和所有的内核模块，以及内核所维护的数据。
- 用户运行一个程序，程序所创建的进程开始运行在用户态，如果要执行文件操作、网络数据发送等操作，必须通过write、send等系统调用。这些系统调用会调用内核中的代码完成操作。这是就需要切换到Ring0，即到3G-4G那部分的内核地址空间去执行这些代码完成。完成后再切回Ring3.回到用户态。
- 这样就保证用户态不能随便操作内核地址空间，具安全保护作用。
- 保护模式：说的是通过内存页表操作等机制，保证进程间地址空间不互相冲突，一个进程的操作不会修改另外一个进程的地址空间的数据。
```



### 进程的堆栈

```
- 每个进程都有自己的堆栈，内核创建一个新的进程时，在创建进程控制块task_struct同时，也为进程创建自己的堆栈。
- 一个进程有2个堆栈，用户堆栈 和 系统堆栈。
- 用户堆栈的空间 指向 用户地址空间。内核堆栈的空间 执行 内核地址空间。
- 进程在用户态运行时，CPU 堆栈指针寄存器 指向 用户堆栈地址，使用用户堆栈。
  在内核态时，CPU堆栈寄存器指向的是内核堆栈空间地址，使用的是内核栈。
```



### 进程 用户栈 和 内核栈之间的切换

```
- 进程由于 中断或系统调用 从用户态转为内核态时，进程所使用的栈 也从用户态切换到内核态。
- 系统调用实质就是通过 指令产生中断， 称 “软中断” 。
- 切换过程：（用户态到内核态）
	进程因为中断（软中断或硬件产生的中断)，使CPU切换到特权工作模式，此时进程陷入内核态，进程进入内核态后，首先把 用户堆栈地址保存在内核堆栈中 → 然后设置堆栈指针寄存器的地址为 内核栈地址。 
	这就完成了用户栈向内核栈的切换。
- 切回过程：（内核态到用户态）
	把保存在内核栈中的用户地址恢复到CPU栈指针寄存器即可，就完成了内核栈到用户栈的切换。
	（PS：每次进入内核堆栈时，内核堆栈信息总是空的，因为内核地址保存进程在内核态运行的相关信息，但是当进程完成内核态运行，重新回到用户态，此时内核栈保存的信息就全部恢复。所以从用户态进入内核态时，直接获取内核堆栈的堆顶地址即可。）
```





## 四、线程同步的方式

https://blog.csdn.net/guoxiang3538/article/details/79376191

```
临界区：
- 通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源 
  进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一   直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。它并不是核心对象，不是属于操作系统维护   
  的，而是属于进程维护的。

- 互斥量：采用互斥对象机制。只有拥有互斥对象（排他锁）才能访问公共资源。同一时间只能有一个线程获得互斥对象。
- 信号量：多个锁的形式，但是数量有限，能控制最大访问线程数，互斥量就是特殊的信号量形式。
- 事件：通过通知操作的方式保持多线程同步，可以方便实现多线程优先级。
```



## 五、死锁产生的四个条件

```
- 互斥条件：多个线程同时竞争一个资源
- 请求和保持条件：一个线程请求一个资源不可得而阻塞的时候，持有原有的资源不释放。
- 不剥夺条件：进程获得资源后，未使用完之前不会释放资源。
- 循环等待：若干进程形成一种头尾相接的环形等待资源关系。
```





## 六、进程三种状态

```
就绪：进程已经分配到除了CPU以外的所有必要资源，只要获得处理器，就可以立即执行。
执行：已经获得处理器，此时正在执行。
阻塞：等待某个事件或者信号，不等不暂停放弃处理器资源进入等待阶段。
```





## 七、分页和分段的区别

```
1.目的

页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页是出于系统管理的需要而不是用户需要。

段是信息的逻辑单位，它含有一组其意义相对完整的信息。分段的目的是为了更好地满足用户的需要。

2.长度

页的大小固定而且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面。

段的长度不固定，决定于用户所编写的程序，通常由编译程序在对程序进行编译时，根据信息的性质来划分。

3.地址空间

页的地址空间是一维的，即单一的线形地址空间，程序员只要利用一个记忆符就可以表示一个地址。

作业地址空间是二维的，程序员在标识一个地址时，既需要给出段名，又需给出段内地址。

4.碎片

分页有内部碎片无外部碎片

分段有外部碎片无内部碎片

5.绝对地址

处理器使用页号和偏移量计算绝对地址

处理器使用段号和偏移量计算绝对地址

6.管理方式

对于分页，操作系统必须为每个进程维护一个页表，以说明每个页对应的的页框。当进程运行时，它的所有页都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个空闲页框列表。

对于分段，操作系统必须为每个进程维护一个段表，以说明每个段的加载地址和长度。当进程运行时，它的所有短都必须在内存中，除非使用覆盖技术或虚拟技术，另外操作系统需要维护一个内存中的空闲的空洞列表。

特别的，当使用虚拟技术是，把一页或一段写入内存时可能需要把一页或几个段写入磁盘。

7.共享和动态链接

分页不容易实现，分段容易实现




https://blog.csdn.net/wang379275614/article/details/13765599
分页存储：
	分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。块大小=页大小=4KB；
	页的地址结构：页号P | 位移量W ，算逻辑地址：
	逻辑地址=页号&位移量（&号是连接符号，是将页号作为逻辑地址的最高位）
	地址映射：
	页号&位移量 = 块号&位移量， 块号记录在页表中，查页表得到物理地址。

分段存储：
	逻辑空间分为若干个段，每个段定义了一组有完整逻辑意义的信息（每个段都是完整的，如每个方法代码存在每个段）
	内存空间为每个段分配一个连续的分区。
	段的长度由相应的逻辑信息组的长度决定，因而各段长度不等，引入分段存储管理方式的目的主要是为了满足用户（程序员）在编程和使用上多方面的要求。　
	地址映射：
	 分两部分：段号、位移量（段内地址）。
	 段内地址的位数可以决定段的大小。
	 逻辑地址=段号&段内地址（&号是连接符号，是将段号作为逻辑地址的最高位）。
	 （物理地址=基址+段内地址）（注意为+号，而不是&号）
	 所以只要求出基址即可。基址与段号存在段表中。
	
	
	要注重理解，完整的逻辑意义信息，就是说将程序分页时，页的大小是固定的，只根据页面大小大小死生生的将程序切割开；而分段时比较灵活，只有一段程序有了完整的意义才将这一段切割开。（例如将一个人每隔50厘米切割一段，即为分页；而将一个人分割为头部、身体、腿部（有完整逻辑意义）三段，即为分段）


```





八、操作系统中进程调度策略

https://blog.csdn.net/luyafei_89430/article/details/12971171

```
--- FCFS，先来先服务策略
	每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或	发生某事件而阻塞后才放弃处理机。
	
--- 短作业优先级（Short Job First）
	就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而	被阻塞放弃处理机时再重新调度。	
	

--- 高优先权调度（FPF）：
	从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程，这时，又可进一步把该算法分成如下两种。
（1）非抢占式优先权算法
	在这种模式下，OS分配处理机给最高优先级的程序，该进程一直执行，直至完成。或者因为某些事件放弃。再重新分配给其他进程。

（2）抢占式优先权算法
	OS会分给当前优先级最高的进程，赋予处理器执行；如果执行过程，出现优先级更高的进程，则中断当前进程，让更高优先级的进程执行。

--- 高响应比优先调度算法
	短作业优先算法是一种比较好的算法，不足是长作业容易饥饿。所以高响应比设置一个动态优先权，随着等待时间的变长，优先权以速率a增加，最终长作业必然执行。
	该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。


--- 时间片轮转
	按先来先服务，入就绪队列，每个进程依次执行一个固定长的时间片时间长度，执行完则进程结束，未在时间片内执行完则入队列尾部，重新等待时间片分配。


```



## 八、死锁处理机制和解除常用方法

```
解决死锁基本方式：
- 预防死锁
	资源一次性分配（破坏请求保持条件）、可剥夺资源（未能全部获取，释放已有的）、资源有序分配（破坏循环等待）

- 避免死锁
	银行家算法（当一个进程申请使用资源的时候，银行家算法通过先 试探 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。）
	银行家算法：https://blog.csdn.net/qq_33414271/article/details/80245715
	
- 检测死锁
	建立资源分配表和进程等待表，判断。
- 解除死锁
	剥夺资源、撤销进程、线程，释放资源。
```





## 九、硬中断软中断

https://blog.csdn.net/zhangskd/article/details/21992933#commentBox

**硬中断：**

\1. 硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通常是内核中的一个子程序，而不是一个独立的进程）。

\2. 处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU（也有一种特殊的情况，就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。）。

**软中断：**

软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的。软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情（通常为I/O）的请求。





## 十、OS中进程通信方式

​	进程间通信主要：管道、系统IPC（消息队列、信号量、共享存储）、SOCKET

### 管道（三种）

1)普通管道PIPE ： 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用.

2)流管道s_pipe ：去除了第一种限制,可以双向传输

3)命名管道:name_pipe ：半双工。去除了第二种限制,可以在许多并不相关的进程之间进行通讯.

### 信号量（Semophore）

实质是计数器，可用来控制多个进程对共享资源的访问，常用来做锁，作为进程、线程同步的一种方式。

### 消息队列

消息的链表，优势在于通信见信息量不受限，并且相比管道可以传输有格式的数据。

### 信号

用于通知进程某个事件已经发生。

### 共享内存( shared memory ) 

多个进程可同时访问，最快的IPC方式，配合信号量使用。（共享资源）

### 套接字( socket ) 

与其他通信机制不同的是，它可用于不同机器间的进程通信。





























