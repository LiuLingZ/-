

https://blog.csdn.net/xiongluo0628/article/details/81461053

http://m.nowcoder.com/discuss/62723?headNav=www

## 一、进程与线程的关系以及区别

​	从粒度、资源占用、开销分析。

### 1、定义

进程：是具备独立运行功能的程序，拥有属于自己的内存空间和资源。一个进程包含多个线程。

线程：线程是进程的一个实体，不能独立存在，线程间共享进程的资源。是最小的具备独立运行能力的基本单位。线程可以看做是轻量级进程。

### 2、关系

一个进程可以创建多个线程，多个线程可以在一个进程中并发执行。

### 3、区别

粒度上：线程远小于进程。

资源上：线程间共享进程的资源，进程是资源拥有的基本单位。

开销上：进程是巨大的，进程间执行、切换开销大，线程小很多。

![img](https://img-blog.csdn.net/20180807102459192?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpb25nbHVvMDYyOA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

​	进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。 
简单来记： 
1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 
5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 
4. 优缺点： 
  线程开销小，但不利于资源的管理和保护；进程与之相反。





## 二、Windows下的内存管理

1、虚拟内存

​	最适合用来管理大型对象或数据结构。

2、内存映射文件

​	最适合用来管理大型数据流（通常来自文件）以及在单个计算机上运行多个进程之间共享数据 。

3、内存堆栈

​	最适合用来管理大量的小对象。













## 三、内核态和用户态



### 内核态

```
- 当一个任务执行系统调用陷入内核代码中执行时，称进程进入了内核运行态（简称内核态）
- 内核态中，处理器处于特权级别最高的 0级 内核代码中。
- 进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。
```



### 用户态

```
- 进程在执行用户自己的代码时，称其处于用户运行态（用户态）.
- 用户态，处理器处于特权级最低的（3级）用户代码中运行。
- 用户态时，如果正在执行的用户程序突然被中断程序中断，此时用户程序也可象征性称为处于进程的内核态。因为中断处理程序使用当前进程的内核栈。这雨处于内核态的进程的状态类似。
```



### 区别、小结

```
- 用户态和内核态时OS的两种运行级别，和CPU没有必然联系。
- intel cpu提供Ring0-Ring3三种级别的运行模式。0最高，3最低。
- 没有使用Ring1和Ring2 。 Ring3不能访问Ring0的地址空间，包括代码和数据。

- Linux进程的4GB地址空间， 3G-4G部分是共享的，是内核的地址空间，存整个内核的代码和所有的内核模块，以及内核所维护的数据。
- 用户运行一个程序，程序所创建的进程开始运行在用户态，如果要执行文件操作、网络数据发送等操作，必须通过write、send等系统调用。这些系统调用会调用内核中的代码完成操作。这是就需要切换到Ring0，即到3G-4G那部分的内核地址空间去执行这些代码完成。完成后再切回Ring3.回到用户态。
- 这样就保证用户态不能随便操作内核地址空间，具安全保护作用。
- 保护模式：说的是通过内存页表操作等机制，保证进程间地址空间不互相冲突，一个进程的操作不会修改另外一个进程的地址空间的数据。
```



### 进程的堆栈

```
- 每个进程都有自己的堆栈，内核创建一个新的进程时，在创建进程控制块task_struct同时，也为进程创建自己的堆栈。
- 一个进程有2个堆栈，用户堆栈 和 系统堆栈。
- 用户堆栈的空间 指向 用户地址空间。内核堆栈的空间 执行 内核地址空间。
- 进程在用户态运行时，CPU 堆栈指针寄存器 指向 用户堆栈地址，使用用户堆栈。
  在内核态时，CPU堆栈寄存器指向的是内核堆栈空间地址，使用的是内核栈。
```



### 进程 用户栈 和 内核栈之间的切换

```
- 进程由于 中断或系统调用 从用户态转为内核态时，进程所使用的栈 也从用户态切换到内核态。
- 系统调用实质就是通过 指令产生中断， 称 “软中断” 。
- 切换过程：（用户态到内核态）
	进程因为中断（软中断或硬件产生的中断)，使CPU切换到特权工作模式，此时进程陷入内核态，进程进入内核态后，首先把 用户堆栈地址保存在内核堆栈中 → 然后设置堆栈指针寄存器的地址为 内核栈地址。 
	这就完成了用户栈向内核栈的切换。
- 切回过程：（内核态到用户态）
	把保存在内核栈中的用户地址恢复到CPU栈指针寄存器即可，就完成了内核栈到用户栈的切换。
	（PS：每次进入内核堆栈时，内核堆栈信息总是空的，因为内核地址保存进程在内核态运行的相关信息，但是当进程完成内核态运行，重新回到用户态，此时内核栈保存的信息就全部恢复。所以从用户态进入内核态时，直接获取内核堆栈的堆顶地址即可。）
```



































