复杂度表

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20160924191851607)







# 冒泡排序 O(n²)

```
思想：大的一直往后排，想到与一直往后冒。
过程：
	- i = 0 , j = list.length()-1
	- 从第一位开始，相邻两位比较大小，大的在后小的在前交换顺序，直到比到j
	- 此时j是最大的，j-- ;
	- 重复上面两步，直到 i == j 。比较完成。


```



# 快速排序 O(nlogn)

```
思想：选一个中点，然后分两边再重复这个过程，分治的思想。
过程：
	1、任选一个中点（一般就是中间那个），取为k，头尾分别为i, j
	2、从i开始，比较k，如果k大于i，i++ ；
	   如果大于k，则交换位置，i++,去开始比较j 。
	3、比较 k，j 。如果 k小于j， j-- ；
	   如果k大于j，交换位置，j--,去比较i 。
	4、重复 2、3步，知道 i==j 。此次遍历结束，此时 k位于自己合适的位置
	5、分两个区间 [i,k-1],[k+1,j]分别重复上面4个步骤。
	
eg :
	第一次定位 k = 5 的位置，
	7 8 1 2 5 6 9 3 4
	5 8 1 2 7 6 9 3 4
	4 8 1 2 7 6 9 3 5
	4 5 1 2 7 6 9 3 8
	4 3 1 2 7 6 9 5 8
	4 3 1 2 5 6 9 7 8
	第一趟后，小于5的都在左边，大于5的都在右边
	分两段：
	[4 3 1 2]     [6 9 7 8]
	继续相同步骤。
```





# 直接插入排序 O(n²)

```
思想：将后面的未排序的数，依次插入到前面的已经排序好的合理的位置
过程：eg:  1 3 4 2 6 5
	- 从i=0开始，1已经排序好（就一个）
	- 1 3		4 2 6 5    （i=1）
	- 1 3 4			2 6 5	(i=2)
	- 1 2 3 4		6 5		(i=3) 从i=2往前找，找到2合理的位置后放下去，i++
	- 1 2 3 4 6		5		（i=4）
	- 1 2 3 4 5 6		（1=5）从i=4往前找，找到5合理的位置放下去，i++
```



# 希尔排序 O((nlog(n))²)

```
思想：通过一个增量列表，如[5,3,1]，通过间隔排序，直到间隔只为1，实现最终排序。通过整体有序再到最后局部有序
过程：
	每次取一个增量，增量作为间隔。
	i,i+5,i+10一组，
	i+1,i+6,i+11一组
	然后组内再进行 插入排序
	再取增量重复。
	
```



# 选择排序 O(n²)

```
思想：选出最小的，放在最前面
过程：
	1、从待排序序列中，找到关键字最小的元素； 
	2、如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换； 
 	3、从余下的 N - 1 个元素中，找出关键字最小的元素，重复1、2步，直到排序结束。

```



# 堆排序

```/\
思想：主要是通过大顶堆和小顶堆，在列表中是有规律可循，列表是依次存放的。
	 初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一	  个堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)	  个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对它们作交换，最后得到有		n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的 	   最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗	 透函数实现排序的函数。

			
```



# 归并排序

https://www.jianshu.com/p/33cffa1ce613

```
思想：将数组整个一直二分，直到只剩一个元素，然后再回归上层重新排序
```

eg：

![è¿éåå¾çæè¿°](https://img-blog.csdn.net/20170906101723017)

- 时间复杂度：O（nlog2n）
- 空间复杂度：O（n）



# 基数排序

```
思想：
	将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低	 位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有	   序序列。
```

![åºæ°æåºLSDå¨å¾æ¼ç¤º](https://itimetraveler.github.io/gallery/sort-algorithms/radix-sort_sample.gif)

- 时间复杂度：O（d（n+r））
- 空间复杂度：O（n+r）
- **d 为位数，r 为基数，n 为原数组个数**。







