

​	key过期是在redis内存还没有溢出时的策略，通过主动、被动两种方式定期清除一些过期的key，防止内存已经满了导致的性能下降或者错误。

​	但是key过期清除策略并不一定能保证不会出现满内存：达到maxmemory的情况，如果满了，就需要进行内存淘汰策略。



**对于主从模式，只有主节点！！主节点！！才会对key进行key过期策略，然后通过同步，同步给从节点（同步del命令），这样能保证主从的数据一致性。**

# Key过期策略

https://www.cnblogs.com/chenpingzhao/p/5022467.html

```shell
setex key1 20 value #20s过期
ttl key1 #查看过期时间
# Redis2.8开始的，如果key2不存在，设置值为true，并且设置过期时间 5s ，可以作为分布式锁
set key2 true ex 5 nx  
```

说明：Redis2.6以后expire精度可以控制在0到1毫秒内，**key的过期信息以绝对Unix时间戳的形式存储**（Redis2.6之后以毫秒级别的精度存储），所以在多服务器同步的时候，**一定要同步各个服务器的时间**



## 1、keys过期键删除策略

- **被动删除**：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key

- **主动删除**：惰性删除策略无法保证冷数据被及时删掉，所以Redis会**定期主动淘汰一批已过期的key**

- （以及到达maxmemory时的内存淘汰的六种方式）



### （1）被动删除

```
- CPU友好，只有用到了才判断是否失效，再删除
- 内存不友好，会造成内存泄漏，一些冷数据一直占用内存，对于依赖内存的服务器，肯定不好。
```

### （2）主动删除

```
- 主动删除是redis时间事件中的一个事件，时间事件指定期执行的维护的事件，如持久化，同步，检查更新状态等
- 主动删除每隔一段时间就执行一次
- redis2.8开始可以配置“hz”参数修改执行的时间频率，默认是10，每1s执行10次

主动删除方式：
- 随机测试设置了过期时间的key
- 删除所有发现的已过期的key
```



​	**当REDIS运行在主从模式时，只有主结点才会执行上述这两种过期删除策略，然后把删除操作”del key”同步到从结点。**



# 内存淘汰策略

https://www.cnblogs.com/changbosha/p/5849982.html

​	即使通过主动删除和被动删除两种策略，还是很不幸得达到maxmemory情况，则需要动用内存淘汰策略。

​	通过 `# maxmemory <bytes>`设置。

六种淘汰策略：

```shell
- noeviction：当内存使用达到阈值的时候，所有引起申请内存的命令会报错。
- allkeys-lru：在主键空间中，优先移除最近未使用的key。
- volatile-lru：在设置了过期时间的键空间中，优先移除最近未使用的key。
- allkeys-random：在主键空间中，随机移除某个key。
- volatile-random：在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：在设置了过期时间的键空间中，具有更早过期时间的key优先移除。
```























