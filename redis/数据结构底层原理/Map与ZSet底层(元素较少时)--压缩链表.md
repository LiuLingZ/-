<https://juejin.im/book/5afc2e5f6fb9a07a9b362527/section/5b5c95226fb9a04fa42fc3f6>



# 压缩链表

​	当字典 和 zhash 存储的对象个数较少的时候，采用 压缩链表存储 (ziplist)

​	压缩链表：一块连续的内存空间，就像是数组，没有任何冗余空间。



## 1、结构体



```c++
struct ziplist {
    int32 zlbytes ;  //整个压缩链表的长度
    int32 zltail_offset ;  //压缩链表最后一个元素距离起始位置的偏移量，用于快速定位最后一个节点
    int16 zllength ; // 元素个数
    T[] entries ;  //元素本体，数组来着
    int8 zlend ;	//结束位标识，默认 OxFF
}

zltail_offset ：从头到尾的偏移量，可以逆序访问，可以直接获取最后一个。

struct entry{
	int<var> prevlen ;   // 上一个节点的长度，比较特殊
	int<var> encoding ;  // 这个节点的编码方式，决定了这个元素的长度和内容形式。
	optional byte[] contents ;  // 元素内容
}

prevlen : 如果上一个元素的长度小于 254(0xFE) ，用一个字节表示 ； 如果>= 254 ，则用5个字节。
		其中，第一个字节是：254, 后面四个字节表示字符串长度
		


```



## 2、级联更新

​	ziplist 是紧密的数据结构，所以当插入元素后可能导致元素的大量迁移，造成资源消耗，所以不宜存储长的字符串或者存的元素不能太多。

​	而**级联更新**：因为有个prevlen 指定前一个元素的长度(1或5字节表示)，如果上个长度为253，更新后变254，则导致prevlen需要更新为5个字节。

​				而如果当前元素也存储了253个字节，因为prevlen变长了，整体变长，所以她的下一个也要更新为5个字节的prevlen，如果恰巧都是存了253个字节的元素，就会导致后面级联更新。

​				除了更新、插入可能导致级联更新，删除操作也会。但凡前个元素的长度发生改变的操作，都有可能导致级联更新。



## 3、IntSet 小整数集合

​	如果set集合存的元素都是整数并且元素个数较少，Redis就会用 intset 存储。

​	intset 也是紧凑的数组结构，同时支持 16 \ 32 \ 64位整数。









​	









