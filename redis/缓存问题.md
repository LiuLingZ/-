https://blog.csdn.net/zeb_perfect/article/details/54135506

# 缓存穿透

### 1、概念

​	指的是，客户端请求一个不存在的，或者id很大的key ，因为没查到，所以也没有缓存，这导致每次请求都去查库。 一般是客户端在攻击服务端。

### 2、解决

​	如果查询不到结果，也缓存这个空结果，但过期时间不是很长，避免存在新的数据



# 缓存雪崩

### 1、概念

​	指大面积的缓存在同一个时间内集体失效，导致大量请求又涌入数据库。

### 2、解决

​	可以尝试给缓存的过期时间乘以一个随机数，即不要统一过期时间，减小缓存雪崩的可能。

​	或者，可以设置消息队列，当超出多少请求的时候，新来的请求如队，然后异步一个线程去先返回结果，显示当前人	多，请稍后，然后读秒。队列的依次进入请求，然后服务器处理完后再返回给客户端数据便可。



# 缓存击穿

### 1、概念

​	缓存击穿指的是对一个热点数据的大量频繁访问，缓存雪崩是对一片key的热点访问，缓存击穿是对一个key的热点访问。如果这个key失效，而又大量请求，就发生缓存击穿。



### 2、解决

#### （1）使用互斥锁

​	redis里有类似 setnx 的语句，代表不存在才能设置，那么就定义一个额外的变量，mutex_key，让他去setnx ,只有设置成功的（返回值为1）才可访问DB，否则不能访问,等待一段时间再查缓存，应该就有了。

```java
/**
*	伪代码
*/
public String get(key) {
      String value = redis.get(key);
      if (value == null) { //代表缓存值过期
          //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db
		  if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
               value = db.get(key);
                      redis.set(key, value, expire_secs);
                      redis.del(key_mutex);
              } else {  //这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可
                      sleep(50);
                      get(key);  //重试
              }
          } else {
              return value;      
          }
 }

```

