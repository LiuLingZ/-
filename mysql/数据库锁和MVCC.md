#一、共享锁与排它锁

##共享锁（Shared locks, S-locks）

**共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。**

能给未加锁和添加了S锁的对象添加S锁。对象可以接受添加多把S锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

用法：

SELECT ... **LOCK IN SHARE MODE**;

在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

## 排它锁（Exclusive locks, X-locks）

排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获得排他锁的事务既能读数据，又能修改数据。

只能给未加锁的对象添加X锁。对象只能接受一把X锁。加X锁的对象不能再加任何锁。

用法：

SELECT ... **FOR UPDATE**;

在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。



#二、补充

## 1、加锁时机

		只有在你增删改查时匹配的条件字段带有索引时，innodb才会使用行级锁，在你增删改查时匹配的条件字段不带有索引时，innodb使用的将是表级锁。因为当你匹配条件字段不带有所引时，数据库会全表查询，所以这需要将整张表加锁,才能保证查询匹配的正确性。在生产环境中我们往往需要满足多人同时对一张表进行增删改查，所以就需要使用行级锁，所以这个时候一定要记住为匹配条件字段加索引。
共享锁：SELECT ... LOCK IN SHARE MODE;

排他锁：SELECT ... FOR UPDATE;



##2、 意向锁

### (1) 机制

​	为了让表锁 和 行锁共存。在InnoDB引擎中支持行锁和表锁。当想给行 写 时，该事务先获得表的意向排他锁，表示独占此表，其他事务不可写，意向排他锁只能有一个，其他阻塞；读行时，获得表的意向共享锁，表示不可修改，但是可一起读，不会阻塞。



意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说**一个数据行加共享锁前必须先取得该表的IS锁**。

意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在**一个数据行加排他锁前必须先取得该表的**

​				**IX锁**

### （2）级别

​	是表级的，因为这样就不用去遍历表的每一行判断是否加了锁。



**意向锁是InnoDB自动加的，不需要用户干预。**



##3、临时锁与持续锁

根据锁的时效判定是在语句结束释放锁还是在事务结束释放锁。



##4、 表级锁与行级锁

锁的粒度，指明了加锁的对象是当前表还是当前行。



## 5、 悲观锁与乐观锁

###悲观锁（Pessimistic Locking）

悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。

尽管悲观锁能够防止丢失更新和不可重复读这类问题，但是它非常影响并发性能，因此应该谨慎使用。

###乐观锁（Optimistic Locking）

乐观锁假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上的锁定。乐观锁使用由程序逻辑控制的技术来避免可能出现的并发问题。

唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁。

乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。

\6. 三级加锁协议

有个大前提一定注意，单纯的读数据不需要加锁，所以可以在加X锁的时候进行纪录读取。

三级加锁协议也称为三级封锁协议,是为了保证正确的调度事务的并发操作,事务在对数据库对象加锁,解锁是必须遵守的一种规则。

6.1 一级加锁协议

事务在修改数据前必须加X锁，直到事务结束（事务结束包括正常结束(COMMIT)和非正常结束(ROLLBACK)）才可释放；如果仅仅是读数据，不需要加锁。

如下例：

SELECT xxx FOR UPDATE;

UPDATE xxx;

一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。

在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。

6.2 二级加锁协议

满足一级加锁协议，且事务在读取数据之前必须先加S锁，读完后即可释放S锁。

二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

6.3 三级加锁协议

满足一级加锁协议，且事务在读取数据之前必须先加S锁，直到事务结束才释放。

三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。

上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。

\7. 两段锁协议（2-phase locking）

两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。

加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。

遵循两段锁协议的事务调度处理的结果是可串行化的充分条件，但是可串行化并不一定遵循两段锁协议。

两段锁协议和防止死锁的一次封锁法的异同之处，一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议；但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

五、不同的事务隔离级别与其对应可选择的加锁协议

| 事务隔离级别 | 加锁协议   |
| ------ | ------ |
| 读未提交   | 一级加锁协议 |
| 读已提交   | 二级加锁协议 |
| 可重复读   | 三级加锁协议 |
| 串行化    | 两段锁协议  |

封锁协议和隔离级别并不是严格对应的。





# 三、MVCC

https://blog.csdn.net/aoxida/article/details/50689619

https://www.jianshu.com/p/7e967d291c24



mvcc,Multiversion Concurrency Controll,多版本并发控制。

Mysql中有读锁和写锁，在没有引入MVVC之前，读锁是允许共享读，但是如果一行记录事先被上了写锁，那么就不允许其他事务进行读，现在的大部分应用都具有读多写少的特性，所以为了进一步增加并发读的性能，引入了MVVC-----Multi Version Concurrency Control（多版本并发控制）。

**解决：被加了写锁的数据在没有变化前可读。（要不要读是根据事务隔离级别判定的。）**



## 实现原理

MVCC可以提供基于某个时间点的快照,使得对于事务看来,总是可以提供与事务开始时刻相一致的数据,而不管这个事务执行的时间有多长.所以在不同的事务看来,同一时刻看到的相同行的数据可能是不一样的,即一个行可能有多个版本.是否听起来不可思议呢?

原来,为了实现mvcc, innodb对每一行都加上了两个**隐含的列**,其中一列存储行**被更新的”时间**”,另外一列存储行**被删除的”时间”**. 但是innodb存储的并不是绝对的时间,而是与时间对应的数据库系统的版本号,每当一个事务开始的时候,innodb都会给这个事务分配一个递增的版本号,所以版本号也可以被认为是事务号.对于每一个”查询”语句,innodb都会把这个查询语句的版本号同这个查询语句遇到的行的版本号进行对比,然后结合不同的事务隔离等级,来决定是否返回该行.

（关键字：并发读没问题，出现写为了提升效率可读，通过时间戳（一个是更新时间、一个是删除时间）形式实现乐观锁，在事务结束前根据设定的事务隔离级别，判断是否需要回退还是直接返回结果。）





​	