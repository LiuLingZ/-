# 事务和死锁

[参考](https://www.cnblogs.com/xrq730/p/5087378.html)

## 

## 一、概念

1、仅InnoDB数据引擎支持数据库的事务

2、为了保证数据库的完整性，保证一套流程要么全做，要么不做。

​	事务，是完成一个功能的工作单位，包含了一条或多条的SQL语句。事务是要么完成，要么不完成。在并发中，如果不对数据库进行约束，则可能产生丢失更新、脏读、幻读、不可重复读等问题。事务有四个特性ACID。事务的隔离级别就是为了防止并发过程可能出现的问题。



## 二、事务的四个基本要素 ACID

1、原子性 （Atomicity）

​	事务是数据库执行逻辑的基本单位，一个事务的内容，要么全执行，要么不执行，执行失败就回滚。

2、一致性（Consistency）

​	指一个事务必须从数据库的一个一致性状态转移为另外一个一致性状态。事务开始前后，数据库的完整性约束没有被破坏（eg:A账户扣了钱而B账户钱没增长）

3、隔离性 (Isolation)

​	一个事务执行过程，其内部对外不可见，事务间互不干扰。一个时间内仅有一个事务可以处理请求的同一数据。

4、持久性 (Durability)

​	一个事务执行后的结果是永久更新到数据库中或磁盘中的保存的，不能回滚。



##三、事务并发出现的几个问题

1. 更新丢失

指多个事务同时对同一数据进行修改时，最后修改保存的事务将覆盖其他事务原先的修改。导致更新丢失。使用排它锁可以解决此问题。

eg : 多个编辑人员对同一份文件进行修改，最后一名保存的编辑人员将直接覆盖了其他编辑人员的修改，实为 更新丢失。

2. 脏读

脏读指事务A读取事务B正在处理的一个数据的值后，事务B发生某种原因导致回滚，此时事务A读取的数据不是正确的，称为“脏读” 。

3. 不可重复读

指事务两次读取同一个数据是显示不相同的结果。

如事务A读取了数据a，事务B修改了数据a,事务A再次读取数据a时，已经和第一次的不相同。

4. 幻读 

事务两次读取数据是，发现第二次多了或者少了一些数据。

如事务A读取数据时显示的是ABC三个等级，而事务B将C等级划分为C、D，即第二次读是读到的是ABCD，增加了一项。



##四、事务的隔离级别

1、读未提交（READ_UNCOMMITTED）

​		内容：未提交的写事务只允许其他读事务，不允许写事务。

​		解决：更新丢失问题（两个写事务同时写，写完才提交）

​		问题：存在脏读，幻读，不可重复读问题

2、读已提交（READ_COMMITED）

​		内容：未提交的写事务禁止其他 读、写事务

​		解决：更新丢失、脏读

​		问题：不能解决重复读问题(读事务读一个数据，写事务修改，读事务再读就不对了)幻读

3、可重复读（REPEATABLE_READ）

​		内容：读取时加锁(SELECT * FROM ``` for update)，表示禁止其他事务修改

​		解决：更新丢失、脏读、可重复读

​		问题：存在幻读，因为读虽然已经不让修改，但是允许增加

4、序列化（SERIALIZABLE）

​		内容：每个事务依次顺序执行

​		解决：更新丢失、脏读、可重复读、幻读

​		问题：效率低下，变成串行化了





## 五、事务隔离怎么实现

###1 、基于锁实现的

### 2、有哪些锁

	#### （1）行级锁

* 特点：

  ​	锁中粒度最小的，锁住操作的那条数据。锁冲突最小，并发度高。但是锁开销大，加锁慢。会出现死锁。

  实现：

  ​	共享锁 和 排他锁

####（2）表级锁

* 特点：

  ​	锁住整张表，是锁粒度最大的。加锁开，开销小，但是并发冲突大，并发性能低。不会出现死锁。

  实现：

  ​	表独占写锁 和 表共享写锁

#### （3）页级锁

* 特点：	

  ​	折中于表级锁和行级锁。一次锁住相邻的一部分数据。并发度一般，锁粒度折中。会出现死锁。

## 六、死锁

### 1、是什么

​	两个或多个事务在同一资源上互相占用，并请求对方的资源，形成的循环等待的结果。

### 2、怎么解决

​	（1）如果有多个事务并发存取多个表，尽量按约定的顺序访问表，可以降低死锁几率

​	（2）同一事务中，尽可能一次性锁定所有的资源，锁定失败时放弃，稍后再重试。（乐观锁、悲观锁）

​	（3）容易发生死锁的业务，可以考虑升级锁粒度。

​	

​	