#一、共享锁与排它锁

##共享锁（Shared locks, S-locks）

**共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。**

能给未加锁和添加了S锁的对象添加S锁。对象可以接受添加多把S锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

用法：

SELECT ... **LOCK IN SHARE MODE**;

在查询语句后面增加LOCK IN SHARE MODE，Mysql会对查询结果中的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。

## 排它锁（Exclusive locks, X-locks）

排他锁又称写锁，如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获得排他锁的事务既能读数据，又能修改数据。

只能给未加锁的对象添加X锁。对象只能接受一把X锁。加X锁的对象不能再加任何锁。

用法：

SELECT ... **FOR UPDATE**;

在查询语句后面增加FOR UPDATE，Mysql会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。



#二、补充

## 1、加锁时机

​	对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。

共享锁：SELECT ... LOCK IN SHARE MODE;

排他锁：SELECT ... FOR UPDATE;



##2、 意向锁

### (1) 机制

​	为了让表锁 和 行锁共存。在InnoDB引擎中支持行锁和表锁。当想给行 写 时，该事务先获得表的意向排他锁，表示独占此表，其他事务不可写，意向排他锁只能有一个，其他阻塞；读行时，获得表的意向共享锁，表示不可修改，但是可一起读，不会阻塞。



意向共享锁（IS）：表示事务准备给数据行加入共享锁，也就是说**一个数据行加共享锁前必须先取得该表的IS锁**。

意向排他锁（IX）：类似上面，表示事务准备给数据行加入排他锁，说明事务在**一个数据行加排他锁前必须先取得该表的**

​				**IX锁**。

### （2）级别

​	是表级的，因为这样就不用去遍历表的每一行判断是否加了锁。



**意向锁是InnoDB自动加的，不需要用户干预。**



##3、临时锁与持续锁

根据锁的时效判定是在语句结束释放锁还是在事务结束释放锁。



##4、 表级锁与行级锁

锁的粒度，指明了加锁的对象是当前表还是当前行。



## 5、 悲观锁与乐观锁

###悲观锁（Pessimistic Locking）

悲观锁假定当前事务操纵数据资源时，肯定还会有其他事务同时访问该数据资源，为了避免当前事务的操作受到干扰，先锁定资源。悲观锁需使用数据库的锁机制实现，如使用行级排他锁或表级排它锁。

尽管悲观锁能够防止丢失更新和不可重复读这类问题，但是它非常影响并发性能，因此应该谨慎使用。

###乐观锁（Optimistic Locking）

乐观锁假定当前事务操纵数据资源时，不会有其他事务同时访问该数据资源，因此不在数据库层次上的锁定。乐观锁使用由程序逻辑控制的技术来避免可能出现的并发问题。

唯一能够同时保持高并发和高可伸缩性的方法就是使用带版本检查的乐观锁。

乐观锁不能解决脏读的问题，因此仍需要数据库至少启用“读已提交”的事务隔离级别。

\6. 三级加锁协议

有个大前提一定注意，单纯的读数据不需要加锁，所以可以在加X锁的时候进行纪录读取。

三级加锁协议也称为三级封锁协议,是为了保证正确的调度事务的并发操作,事务在对数据库对象加锁,解锁是必须遵守的一种规则。

6.1 一级加锁协议

事务在修改数据前必须加X锁，直到事务结束（事务结束包括正常结束(COMMIT)和非正常结束(ROLLBACK)）才可释放；如果仅仅是读数据，不需要加锁。

如下例：

SELECT xxx FOR UPDATE;

UPDATE xxx;

一级封锁协议可以防止丢失修改，并保证事务T是可恢复的。使用一级封锁协议可以解决丢失修改问题。

在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，它不能保证可重复读和不读“脏”数据。

6.2 二级加锁协议

满足一级加锁协议，且事务在读取数据之前必须先加S锁，读完后即可释放S锁。

二级封锁协议除防止了丢失修改，还可以进一步防止读“脏”数据。但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

6.3 三级加锁协议

满足一级加锁协议，且事务在读取数据之前必须先加S锁，直到事务结束才释放。

三级封锁协议除防止了丢失修改和不读“脏”数据外，还进一步防止了不可重复读。

上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放。

\7. 两段锁协议（2-phase locking）

两段锁协议是指每个事务的执行可以分为两个阶段：生长阶段（加锁阶段）和衰退阶段（解锁阶段）。

加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁，在进行写操作之前要申请并获得X锁。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。

解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。

若并发执行的所有事务均遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。

遵循两段锁协议的事务调度处理的结果是可串行化的充分条件，但是可串行化并不一定遵循两段锁协议。

两段锁协议和防止死锁的一次封锁法的异同之处，一次封锁法要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议；但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁。

五、不同的事务隔离级别与其对应可选择的加锁协议

| 事务隔离级别 | 加锁协议   |
| ------ | ------ |
| 读未提交   | 一级加锁协议 |
| 读已提交   | 二级加锁协议 |
| 可重复读   | 三级加锁协议 |
| 串行化    | 两段锁协议  |

封锁协议和隔离级别并不是严格对应的。