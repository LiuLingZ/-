# GC

 **概述:仅供思路，关键点**

```
涉及的参数：

打开GC日志  -XX：+HeapDumpOnOutOfMemoryError ;  -XX:+PrintGCDetail


-Xms
-Xmx

-XX:PretenureSizeThreshold
-XX:+UseAdaptiveSizePolicy

-XX:+UseCMSCompactAtFullCollection
-XX:CMSFullGCsBeforeCompaction
```



##一、回收什么

```
概述：
回收的是那些，已经确定的，不会再被用到的且没有对象去引用的对象。也可以说，回收的是Java堆、方法区上的内存。因为这一部分的内存不像Java虚拟机栈那样编译器大致已知大小。对象的分配只有在运行时才清楚，所以回收其内存也是运行时的。回收的，即是堆、方法区的内存，也是，已经失去引用的，不会再被用到的对象。
```

### （一）、判断对象可回收的方法

#### 1、引用计数器法

​	缺陷：可能存在循环引用，导致内存泄漏：A→B；B→A

#### 2、可达性算法分析

 	- 通过一系列的GC Roots节点作为引用链的根节点，能被引用链引用到的对象就是有效存活的，没有就是失去引用，需要被回收的。

​	- 什么可以作为GC Roots:

​		方法区中的常量或静态变量所引用的对象

​		Java虚拟机栈上所引用的对象

​		JNI所引用的对象 	

​		活跃线程所引用的对象	

#### 3、再谈引用，四种引用类型

​	概述 ： 根据对象时候有被引用判断对象是否存活，这里就牵引出另外的概念，四种引用类型 。 

##### 强引用

- 类似new()创建的，只要强引用存在，对象就不会被回收

##### 软引用

- SoftReference实现软引用

- 软引用代表：**还有用但非必须**

- 当要发生OOM时，就把他们列为可回收对象，先GC一次，发现仍有OOM时，再回收这些软引用对象，回收后还不够才OOM。

  **给一个活的机会，事实不允许，就回收吧**

  

##### 弱引用

- WeakReference实现。

- 代表：**非必须的对象**，GC时一定回收

  **创建用完就回收，不给活**



#####幻影引用

- PhantomReference实现

- 代表：没任何意义，一个对象是否存在幻影引用不影响其自身生命周期

- 目的仅是在对象被回收时发送一个系统通知

  **有没有不影响自己，仅仅被回收器惨叫一声**

  

## 二、什么时候回收

```
概述：当什么情况发生时可以回收？一定回收吗？确定回收是直接开始回收吗？
```

### 1、最后一次求生：finalize( ) 

​	对象被GC会经过两次标记，第一次标记，是标记已经“没有被引用”的对象。那么此时 ；

​	如果这些对象有重写 finalize() 方法，则JVM会将其保存在一个 F-Queue队列中 ，并且稍后，会启动一个低优先级的线程去调用它，但是不保证等它执行完。为什么？因为怕这个对象的finalize方法执行缓慢，或者卡死，导致后面的对象的finalize()执行不了，导致GC崩溃。

​	那么此时，**对象的自救开始了**：如果在finalize() 中获得新的引用，（即被引用），则在JVM第二次标记中，这些对象出F-Queue队列，重获新生。**但是！finalize（）只能执行一次！！！切记** ；

​	如果在这一步还得不到救赎，那么对象 over 。



###2、安全点、安全区

​	概述：并不是说，一旦OOM，就要开始回收，因为此时，程序还在运行，可能对象的引用关系还在变化，GC中，枚举根节点，是要时间的，会 stop-the-word ,随意得中断程序，可能导致程序一些对象被错误回收或者忽略了较多的可回收对象。所以，什么时候可以停下程序中运行的线程，就牵涉除了 **安全点、安全区** 。

#### 安全点

​	所谓安全点，就是线程可以运行到这里停下，而不会修改引用信息，那么什么地方适合作为安全点呢？

​	原则是：**具备让程序长久的特点。**

​	比如：

​		循环入口、方法的调用、异常跳转这些，跳到别的代码块的情况，这些情况未知，可能要执行很久，所以在这之前设置安全点，为的就是做让程序能够“长久运行”的准备 。	

#### 安全区

​	安全的可以不是一个点，只要运行到这片区不修改、不影响即可。也就有了安全区的概念。



#### 引申：如何让线程到达安全区安全点停下：

两种方案：

​	抢占式中断：GC时，强制停止一切线程，然后判断每个线程是否在安全点，不是，则恢复让其跑到安全点。

​				缺点：挂起 恢复线程消耗大，几乎不用。

​	主动式中断：设置一个flag，让每个线程都去轮询flag，如果GC时，flag状态改变，那么线程就停下。

​				这个flag 就设置在 安全点、分配对象的地方，所以发现flag停下，就刚好在安全点。		



## 三、如何回收

### （一） 垃圾回收算法

####标记-清除

​	特点：最基础，后面都是对其优化

​	缺点：

​		1、效率，标记、清除效率都不高

​		2、空间碎片，可能提前触发GC		

####复制

​	特点：1:1 ， 将对象保存到一边，直接清除另外一边

​	优点：速度较快，没有空间碎片

​	缺点：额外的空间担保，空间利用率低

####标记-整理

​	特点：标记清除的升级，标记后，将存活对象整合到一边去，然后清理其余空间

​	优点：没有碎片

​	缺点：效率还是低，标记、整理、清除过程，多了个整理。

####分代收集

​	特点：堆中就是采用这个。 分新生代和老年代，新生代使用复制算法，老年代因为是最后的内存空间，所以必须用标记-整理 或 标记-清除算法。并不能用带空间担保的复制算法。



### （二）垃圾收集器

```
概述：垃圾回收算法是理论，而垃圾回收器就是理论的实践。JVM没有规定垃圾回收器的实现方式。
以HotSpot为例，堆是以分代回收方式，分为新生代和老年代。那么垃圾回收器也有专门负责新生代、老年代的区别：
	新生代： Serial \ ParNew \ Parallel Scavenge \ G1
	老年代： Serial Old \ Parallel Old \ CMS \ G1
```

---



#### Serial

特点：

- 单线程，适合Client模式下的虚拟机堆回收，负责新生代。
- **复制算法**		

#### Serial Old

特点：

- Serial 的老年代版本，单线程
- **复制** 算法 （老年代不能担保，不能复制）



**上二者可以组成单线程的新生、老年代收集器，可能产生较长卡顿，在桌面应用还能接受，服务端不行。单线程也有好处，专心处理GC，效率高**

---

#### ParNew

特点：

- Serial的多线程版本。**复制算法**，很多特点都和Serial一样（回收策略、对象分配规则什么的）
- 老年代可以配合 Serial Old
- 除了Serial ，唯一一个可以和 CMS配合的新生代垃圾回收器。

注意：

​	ParNew在单CPU不会比Serial快， 因为有线程的开销。但是多CPU性能就行。PraNew默认开启的线程数 = CPU的数目。可以通过  **-XX:ParallelGCThreads** 指定线程数 。 

---

#### Parallel Scavenge

​	特点：**复制算法** 、 **自适应策略**

​		注重的是吞吐量，其他的收集器注重的多是减少 GC停顿的时间。也叫“吞吐量优先”收集器。

​		Parallel Scavenge 有个 -XX:+UseAdaptiveSizePolicy参数，打开后回收器会根据当前内存情况调节自己的回收策略，对吞吐量与停顿时间的权衡，自适应调节新生代大小（-Xmn）、Eden 和 Servivor比例(-XX:SurvivorRatio)参数、晋升老年代对象大小（-XX：PretenureSizeThreshold）等等.

#### Parallel Old

​	特点：**标记-整理**

​	在Prallel Old没出来的时候，Parllel Scavenge只能配合Serial Old，因为其无法配合 CMS。

​	直到Prallel Old出来，才算真的**“吞吐量优先”组合**。



---

#### CMS

特点：Concurrent Mark Sweep ， 并发标记清除 。 **以最短回收停顿时间**为目标。符合Server机器。

​	**标记-清除** ！！！！！！ 这涉及到后面一个**并发模型失败**！！！！

过程：

​	初始标记：会stop-xx ， 仅仅是标记被GC Roots直接引用到的对象，速度很快，

​	并发标记：通过GC Roots进行可达性分析。最耗时，但是能和程序一起执行。

​	重新标记：会stop-xx，修正因为并发标记过程程序并发修改的引用。停顿的时间不会太长。

​	并发清除：并发清除。

​	**耗时最长的并发标记和并发清除都不会停，还能接受。**



**注意：提前GC的问题 ：**

```
	因为CMS在GC时，程序还在运行，那么势必可能需要分配对象，此时，CMS不能等到老年代快被用完才GC，因为老年代作为最后的内存空间，一旦不够就OOM了，所以，在老年代达到一定数值时，就触发了GC
	JDK1.5时，在老年代用 68％ ，就GC ；
	JDK1.6开始，提升到 92％ ；
```

**Concurrent Mode Failure**

```
	CMS在GC时，当老年代预留的空间不够分配对象时，就会触发一次 Concurrent Mode Failure ,就会启动别用方案：
临时启动 Serial Old进行中断回收，这下停顿时间就长了，不够能有效清出空间，标记-整理。
```





缺点：

1、CMS对CPU资源的敏感

​	因为CMS是多线程并发的，GC时会产生额外的线程， 消耗CPU资源。CMS默认开启的线程数：

​	（CPU数+3）/ 4 ; 原本有个 “增量式并发收集器”的方案，即不要开太多线程，而是通过“抢占”原有线程的资源的形式

​	去GC，但是效果不好，被废弃。

2、浮动垃圾

​	浮动垃圾指的是，并发清除过程，可能程序又产生了新的垃圾，这部分垃圾没有得到回收，称为浮动垃圾，只能下次

​	GC再清除。

3、空间碎片问题

​	因为CMS是标记-清除。会有空间碎片，解决方案 ： **压缩**

​	① 参数-XX：+CMSFullGCsBeforeCompaction ，代表老年代要Full GC时开启内存碎片合并整理，这是无法并发的，GC时间变长。默认是开的

​	② 参数-XX：+UseCMSCompactAtFullCollection ，此参数设置，多少次不压缩的Full GC后，执行一次带压缩的Full GC，默认0，代表Full GC每次都压缩。	

---



####G1

特点：JDK1.7正式使用，同时兼顾新生代、老年代，几大特点：

```
1、分代收集
	虽然G1还保留着新生代、老年代的概念，但是已经用一个个Region作为内存单元，代替新生对待老年代两块的划分，
	G1管理的也是这一个一个Region 。对于新生代老年代的Region，采用不同的回收策略。
2、空间整合
	不会产生内存碎片。从整体上，G1看起来是标记-整理；而从细节上看，是两个Region在进行复制算法。没有空间碎片	有利于程序长久运行。
3、可预测的停顿
	并不是对所有的Region进行回收，而是通过计算每个Region的回收时间和得到的内存大小做判断，根据权衡选择性回	 收性价比最大的。比如时间就那么多，那就选一个最大性价比的回收。做到类似实时Java回收机制。
```

##### 可预测的停顿

​	为了避免全堆进行GC，JVM维持一个Region回收价值的优先列表，每次回收规定时间内性价比最高的Region，保证每次回收尽可能高效。

##### Remember Set

​	Region实现并不简单，因为存在这么个问题：对象的引用极可能不是在同一个Region中分配的，那么如何避免全堆扫描去找那个引用的对象呢？就用到了 Remembered Set这个数据结构，每个Region内含一个。当一个对象进行引用的写的时候，判断是否在同一个Region中，如果不是，就把对应的region写到Remember Set中。 这样，当要回收的时候，直接扫描Remember Set中。

##### 过程

```
初始标记
	标记GC Roots能直接关联到的对象，会停顿，时间不长，并且修改TAMS的值，为的是让用户能够再接下来能正确使用	 Region.
并发标记
	通过GC Roots进行可达性分析。可以并发执行。
最终标记
	修改因为并发导致的标记偏差。并发执行过程中，对对象引用的修改记录在Remembered Set Logs中，只需要将其与	Remembered Set 合并即可。需要短暂的停顿。
筛选回收
	将Region进行优先级排序，根据用户所期望的停顿时间进行高效益回收。
```

### （三）回收日志

​	[GC类型 [在哪个区发生: xxxxx]]

​	DefNew : Serial 将新生代命名为 ： Default New Generation

​	ParNew : ParNew 将新生代命名为 Parallel New Generation

​	

## 四、堆是怎么回收的

![1](C:/Users/lingz/AppData/Local/YNote/data/m13229401809@163.com/ee2d7e664a114e0aa905e615ef7e13bb/921034534396.png)

	### 1 、内存划分

```
- 根据 1:2,划分为新生代、老年代；新生代再根据 1:1:8划分为 From Survivor \ To Survivor \ Eden 区
- 新生代每次使用1个survivor和eden，GC采用复制算法，将存活的对象存于其中一个空的survivor，然后回收Eden和 	   survivor区 。
- 老年代标记-整理或标记-清除，着垃圾回收器决定。
```

####为什么是8:1:1 ?	

​	因为根据以往经验，大多数对象都是小对象且容易死亡，存活的不多，为了最小化复制算法带来的内存亏损，所以划分为1/10的内存空间作为担保。

​	而老年代作为最后的内存区域，不能再对空间浪费，所以只能标记-整理或标记-清除。

### 2、各自的回收策略

#### Minor GC

​	发生在新生代，比较频繁。速度也比较快

#### Full GC

​	发生在老年代，触发几率比较低，速度比较慢，但是能清除较多空间。

##  

##五、内存分配和回收策略

### 1、大对象

​	大对象直接进入老年代，因为新生代不够放。

### 2、新生代晋升到老年代

​	当新生代的对象，经历过默认是15次minor GC 后，就会晋升到老年代，老年代的对象都是不容易死的。

​	设置 -XX：MaxTenuringThreshold = 15

### 3、动态判断对象年龄

​	当然，不一定要等到达到晋升年龄才能晋升。当新生代中有一半的对象年龄相同并且所占内存超过survivor的一半，那么大于等于这个年龄的对象也可以晋升到老年代。

​	即 ： 相同年龄的对象所占空间 ≥ 1/2 survivor



### 4、空间担保机制

​	发生Minor GC前，JVM会先检查 老年代所剩空间是否大于新生代所有存活对象所占内存，如果大，则这个Minor GC是安全的； 反之不安全，这是，根据判断 HandlePromotionFailure 担保是否允许失败，如果不允许，即不允许冒险，就会提前出发一次 Full GC 。大多数允许冒险，避免频繁 Full GC.





## 六、各种问题

### 1、什么时候GC

```
说到GC，首先要想到的是full gc 和 minor gc 、 major(old) gc
Young GC：也叫minor gc.只收集young gen的GC
Old GC：也叫major gc,只收集old gen的GC。只有CMS的concurrent collection是这个模式
Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。

但是现在发展后定义模糊，full gc可能被说成是老年代的gc，所以还是问清楚，接下来下面都是当做老年代gc 。



minor gc:
- 新生代Eden满了的时候触发。比较频繁。注意，此时可能会有一些对象晋升到老年代。

full gc:
- 当要发生minor gc时，可能先触发full gc,因为老年代作为最后的空间，必须保证剩余空间能容纳新生代所有对象，以防一下子有大量对象涌入，如果发现不够，根据担保策略，触发一次full gc 。
- System.gc()方式也是触发full gc 。



```

