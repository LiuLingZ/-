# 虚拟机类加载机制

####1 、概述

​	虚拟机加载、连接（验证、准备、解析）、初始化Class文件中的数据，最终形成可以被虚拟机直接使用的Java类型，此为虚拟机的类加载机制。

####2、加载时机

​	Java中，类的加载连接初始化都是在程序运行期间完成。可以提高灵活性（动态加载类）。

#### 3、类加载过程

​	· 加载(Loading)、校验(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)

​	· 校验、准备、解析 统称： 连接（Linking）

​	· 其中 加载 、校验 、准备 、初始化 是顺序可交叉执行的，解析则不一定。这和解析的阶段完成的功能有关。解析不

​	  用按顺序执行是为了实现Java语言的运行时绑定（如多态）。



## 加载

1、加载的时机（虚拟机无规定）

​	Java虚拟机没有规定加载的时机，可以按具体情况。

​	但是初始化阶段，虚拟机规范严格规定了有且仅有5种情况必须立即对类进行“初始化” （加载-连接-初始化）



​     **初始化时机 ： **（虚拟机强制规定5种）

​	（1）new一个对象；

​		读取或设置一个类的静态字段（除了final修饰、编译期把结果放入常量池的静态字段外）；

​		读取或设置一个类的静态方法 ；		

​	（2）通过java.lang.reflect包的方法对类进行反射调用，若类无初始化，则先触发初始化；

​	（3）初始化一个类的时候，若父类没有初始化，则先初始化；

​	（4）虚拟机启动时，用户需要指定一个要执行的主类，虚拟机回先初始化这个主类。

​	（5）当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果

​		REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，则需要先触发这个方法句柄所对应的类的初始

​		化。			

​		**主动引用**、**被动引用**

​			这5种会触发类进行初始化的场景，这5种场景的行为称为对一个类进行**主动引用**，此外，所有引用类的方

​		式都不会触发初始化，称为**被动引用**。	



2、加载阶段是开发人员灵活性最大的阶段，可以自定义从哪里加载、如何加载Class文件；可以自定义类加载器

​      然而数组类本身不通过类加载器创建，而是Java虚拟机直接创建。但是数组类型的类，仍是类加载器去创建。

3、加载完成后，Class文件内容按虚拟机内部格式存在方法区（JVM未定义方法区的具体结构）中 。 

​     然后在方法区中（**不是堆中**），创建一个java.lang.Class类的对象，此对象用来作为程序访问方法区中的这些类型数据

​      的外部接口。

4、加载过程和连接过程中的校验阶段是交叉进行的，即加载中可以进行数据校验。



## 验证

​	**校验阶段很重要，但是已经确保了将要运行的代码的正确性，可以通过 -Xverify:none 关闭大多数校验，以虚拟机提高加载类的性能。**

1、简介

​		是连接的第一步，目的是确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害到虚拟机	

​	自身安全。就性能上说，验证阶段的工作量在虚拟机的类加载子系统占了相当大一分。

​		校验分四种：文件格式校验、元数据校验、字节码校验、符号引用校验

2、详解



**文件格式校验**（验证后将在方法区内对存储结构进行验证，不再操作字节流。）

​		验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。通过了这个阶段的验证后，字节

​	流才	会进入内存的方法区中进行存储。后面就会基于方法区的存储结构进行验证，不直接操作字节流了。



**元数据验证** （数据校验，符合语义）

​	此阶段是对字节码的描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求。

​	（通俗的说，就是类的继承关系、实现等是否符合语义。）



**字节码验证**（主要对程序中的方法进行校验）

​	最复杂，确保语义正确，对方法体进行校验分析，保证 程序运行时不会对JVM产生危害。

​	元数据校验是对元数据信息中的数据类型做校验（继承关系），第三阶段是对类的方法体进行校验。

​	此阶段的校验并不是百分百能排查出问题，因为程序不知道自己是否能执行结束。



**符号引用验证**

​	此阶段发生在虚拟机将符号引用转为直接引用的时候（符号引用和虚拟机内存存储无关，直接引用则有） 。这个转化动作发生在 **解析**阶段。（所以这个校验也可能不会先进行！！！）。符号引用验证是为了保证解析阶段顺利进行。

​	如果出错，报 java.lang.IncompatibleClassChangeError异常的类，如java.lang.NoSuchMethodError

​	符号引用验证 可以看成 是**对类自身以外（方法区常量池的各种符号引用）**的信息进行匹配性校验。





## 准备

​	准备阶段是 正式为类变量（static）分配内存并设置类变量初始值（对应类型的0值，实际的值将在初始化阶段获得。）的阶段。变量所使用的内存都将在方法区进行分配。

​	当被final修饰的常量时，在准备阶段就会被赋值成实际的值，而static只是对应0值。



## 解析

​	1 、 虚拟机将方法区常量池中符号引用转为直接引用的过程

​		符号引用:	

​			一组符号来描述所引用的目标，可以是任何形式的字面量。符号引用和虚拟机实现的内存布局无关，引用

​			的目	标不一定加载到内存中。需要时再取。					

​		直接引用：

​			直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。是和虚拟机实现的内存布局相关的。

​	2、解析包括：

​		类或接口的解析（引用类的解析）

​		字段解析

​		类方法解析

​		接口方法解析



## 初始化

1、初始化时真正开始执行类中定义的Java代码

2、

​	初始化阶段是执行类构造器< client>()方法的过程；	

​	< client>()是由编译器自动收集类中的所有类变量的复制动作和静态语句块中语句合并产生；

​	收集顺序按源代码定义顺序；静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面

​	的静态语句块可以赋值，但是不能访问；（可以访问之前定义的，之后定义的只能赋值。）		

​			

3、关于< client>()

​	· < client>() 与 类的构造函数不同，不需要显示地调用父类构造器，这是因为子类的< client>()访问前，父类一定已经

​	   加载了。

​	· 父类的< client>()先执行，说明父类中静态语句块赋值优先于子类。

​	· < client>() 对类或接口不是必须的，没有静态语句块就不必生成< client>()

​	· 接口中不能使用静态语句块，但仍有变量初始化赋值的操作。因为接口和类一样会生成< client>()。但执行接口的

​	  < client>()和类不同，不需要去执行父接口的< client>()。只有父接口的定义的变量被使用，父接口才会初始化。

​      	 另外接口的实现类初始化也一样不会执行接口的< client>()方法。

​	· < client>()只会被执行一次，多线程初始化时只有一个线程执行，其他阻塞。