# 说一下Java内存区域

https://www.cnblogs.com/ityouknow/p/5610232.html

#### 		是什么？	

#### 	线程私有公有？

#### 		本身特征

#### 	是否OOM




### 程序计数器

​	一、是一块较小的内存用来保存程序运行到的字节码的行号

​	二、是线程私有的

​	三、如果运行的是Java方法，则保存的是字节码的行号；如果运行的是native的方法，则保存	

​		的是undefined。 

​	四、因为保存的是程序运行的位置，所以不会发生OOM



### Java虚拟机栈

#####一、描述的是Java方法运行时的内存模型

#####二、是线程私有的

#####三、（栈帧→局部变量表特点）

1、有一个栈帧（Stack Frame）的概念。可以把栈帧理解为一个方法的“内存模块”，保存			局部变量表、操作数栈、动态链接（其他方法或分支）、方法出口等。每个方法的执行与结束，对应该栈帧的入栈、出栈。平时所说的栈空间，就是Java虚拟机栈或者栈帧的局部变量表				

2、关于局部变量表

​	存的是 编译期 已知的各种基本数据类型（boolean \ byte \ char \ short \ int \ float \ double \ long）、对象引用（reference）。

​	64位长的long \ double 会占两个局部变量表空间(slot) 。

​	局部变量表的内存在编译期确定，也即：栈帧分配的局部变量表的大小是完全确定，不会改变。

##### 四、会发生OOM

1、会发生两种OOM的情况：

（1）当线程请求的栈深度超出JVM允许，StackOverflowError 异常。这种就是方法太多，出现在递归情况

（2）大部分的Java虚拟机栈是可以动态扩展大小的，如果扩展申请的内存不能得到满足，OutOfMemoryError。				



### 本地方法栈

##### 一、描述本地方法执行的内存模型

#####二、是线程私有的

##### 三、特点 

​	也是线程私有的。和Java虚拟机栈相互对应，前者是描述Java方法的内存模型，后者是本地方法的	。虚拟机规范没有强制要求实现。虚拟机可以自由实现。

##### 四、OOM

​	同样的，也会存在StackOverflowError、OutOfMemoryError。



### Java堆（Java Heap）

#####一、是存放实际对象的内存

##### 二、是线程共享的

##### 三、特点

1、是JVM中管理的最大的一块内存。虚拟机启动时就创建。

2、几乎说所有的对象都在对分配，但是现在也有栈上分配（JIT和逃逸技术的发展）

​	（关于逃逸分析：https://mp.weixin.qq.com/s/gtKysPvVoTvtu_cApvZHAg）

3、堆也称GC堆，因为垃圾回收主要在堆上进行。现在堆的回收基本都是“分代收集算法”，所以堆也可细分为“新生代”、“老年代”。

4、堆是线程共享的，然而堆中也可划分为多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB），避免一定的线程竞争，毕竟共享的东西独占需要加锁。线程私有的分配缓冲区同步问题可以由Java内存模型解决。总体来说堆是线程共享的，但是在堆的年轻代中的Eden区可以分配给专属于线程的局部缓存区TLAB，也可以用来存放对象。相当于线程私有的对象。

（https://www.cnblogs.com/straybirds/p/8529924.html）



5、堆的大小设置参数：

​	-Xmx 

​	-Xms

##### 四、关于OOM

​	堆中没有内存用于分配实例、或者堆无法扩展，就OOM 。





### 方法区

##### 一、用于存储虚拟机加载的类信息、常量、静态变量、JIT编译后的代码。

##### 二、线程共享的

##### 三、特点

1、Java虚拟机规范是将方法区划分为堆的一部分，但方法区的实现不是在堆中，而是单独的。

2、关于 ： 运行时常量池

​	a. 是方法区的一部分。方法区加载类文件，类文件中含有类的版本、字段、方法、接口等，以及 运行时常量池 。 

​	b. 运行时常量池 存放编译期生成的各种字面量 和 符号引用。(在类被加载后存放到常量池)

​	c. 除了符号引用，编译期翻译出来的直接引用也存储在运行时常量池。

​	d. 运行时常量池相对 Class文件常量池(类文件自己的) 具动态性。并非预置于Class文件常量池的内容才能在编译期进入运行时常量池。运行期也可将新的常量放入池中，应用：String的intern()

3、关于永久代(PermGen)和元空间(Metaspace)

​	a. 两者都是JVM方法区规范的实现。永久代是JDK1.7以前，仅HotSpot虚拟机有；元空间是JDK1.8开始有的

​	b. 元空间不在虚拟机中，在本地内存

​	c. 为什么换成元空间的理由：

​		i. 字符串在永久代中容易出性能问题和内存溢出

​		ii. 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太		

​		    大则容易导致老年代溢出。 因为永久代实际是堆空间逻辑的一部分，在一些实现上和堆占同一内存空间。

​		iii. 永久代也有GC，但是难度大(类卸载条件苛刻)，回收效率低



##### 四、OOM

当常量申请内存空间得不到满足时，同样会OOM。



直接引用：与JVM内存布局相关，能够直接访问到目标的指针或间接访问到目标的句柄。

符号引用：一组符号来描述所引用的目标，可以是任何形式的字面量，与内存布局无关。















