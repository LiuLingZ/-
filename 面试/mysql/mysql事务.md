# 事务

[参考](https://www.cnblogs.com/xrq730/p/5087378.html)



## 一、概念

1、仅InnoDB数据引擎支持数据库的事务

2、为了保证数据库的完整性，保证一套流程要么全做，要么不做。

## 二、事务的四个基本要素 ACID

1、原子性 （Atomicity）

​	事务是数据库执行逻辑的基本单位，一个事务的内容，要么全执行，要么不执行，执行失败就回滚。

2、一致性（Consistency）

​	指一个事务必须从数据库的一个一致性状态转移为另外一个一致性状态。事务开始前后，数据库的完整性约束没有被破坏（eg:A账户扣了钱而B账户钱没增长）

3、隔离性 (Isolation)

​	一个事务执行过程，其内部对外不可见，事务间互不干扰。一个时间内仅有一个事务可以处理请求的同一数据。

4、持久性 (Durability)

​	一个事务执行后的结果是永久更新到数据库中或磁盘中的保存的，不能回滚。



### 三、事务并发出现的几个问题

1. 更新丢失

指多个事务同时对同一数据进行修改时，最后修改保存的事务将覆盖其他事务原先的修改。导致更新丢失。使用排它锁可以解决此问题。

eg : 多个编辑人员对同一份文件进行修改，最后一名保存的编辑人员将直接覆盖了其他编辑人员的修改，实为 更新丢失。

2. 脏读

脏读指事务A读取事务B正在处理的一个数据的值后，事务B发生某种原因导致回滚，此时事务A读取的数据不是正确的，称为“脏读” 。

3. 不可重复读

指事务两次读取同一个数据是显示不相同的结果。

如事务A读取了数据a，事务B修改了数据a,事务A再次读取数据a时，已经和第一次的不相同。

4. 幻读 

事务两次读取数据是，发现第二次多了或者少了一些数据。

如事务A读取数据时显示的是ABC三个等级，而事务B将C等级划分为C、D，即第二次读是读到的是ABCD，增加了一项。





### 四、事务的隔离级别

1、读未提交（READ_UNCOMMITTED）

​		内容：未提交的写事务只允许其他读事务，不允许写事务。

​		解决：更新丢失问题（两个写事务同时写，写完才提交）

​		问题：存在脏读，幻读，不可重复读问题

2、读已提交（READ_COMMITED）

​		内容：未提交的写事务禁止其他 读、写事务

​		解决：更新丢失、脏读

​		问题：不能解决重复读问题(读事务读一个数据，写事务修改，读事务再读就不对了)幻读

3、可重复读（REPEATABLE_READ）

​		内容：读取时加锁(SELECT * FROM ``` for update)，表示禁止其他事务修改

​		解决：更新丢失、脏读、可重复读

​		问题：存在幻读，因为读虽然已经不让修改，但是允许增加

4、序列化（SERIALIZABLE）

​		内容：每个事务依次顺序执行

​		解决：更新丢失、脏读、可重复读、幻读

​		问题：效率低下，变成串行化了