# 垃圾收集器

​	作用年代

​	特点（单/多线程）

​	优缺点



## 一 、 概括

​	垃圾收集器就是内存回收的具体实现。JVM规范没有订制收集器的实现。在JDK1.7中HotSpot虚拟机提供了下面几种收集器：(不同代有不同的收集器)

​	Young generation：

​		Serial 、 ParNew 、Parallel Scavenge 、G1

​	Tenured generation :

​		CMS 、Serial Old 、Parallel Old 、 G1

​	其中G1在新生代和老年代都可起作用。

## 二、先决知识：HotSpot的算法实现

### 1、枚举根节点（Stop The World）	

​	在GC中对象"标记"阶段，有两种算法：引用计数法和可达性分析。大部分都是可达性分析，而要进行可达性分析，就必须在这个时间段的时候，对象都是出于一种"一致性"的状态，这和数据库的一致性原则很相似，这就是说，在这个时间段中，对象间的引用关系是不能变化的，否则从 GC Root出发时，可能先前一个对象已经被引用，但是随着程序的运行，对象又失去引用。而此时可达性分析已经分析了此对象是存活对象，判断出现差池。也可以理解为可达性分析是要求“原子性”的，打了双引号的原子性。所以，这个可达性分析的过程就要求程序相对静止，即对象的引用关系不会改变，这就像程序停止了，所以叫“**Stop The World”.也叫"GC停顿"** 。 

​	几种垃圾回收器大部分都是围绕如何减少这个“Stop The World”时间改进的。因为效率。	

​	还有一个问题，就是可达性分析时需要找GC Root(一般都是全局变量或执行上下文) ， 内存很大，不可能挨个去找，所以虚拟机需要知道GC Root存在哪，这个问题通过 OopMap的数据结构解决。在类加载完时，HotSpot就把对象内什么偏移量存什么数据计算保存在OopMap中，JIT即时编译也会在特定位置记录下栈和寄存器中哪些位置是引用。这样GC时可以直接获取到，提高效率。



###2、安全点

​	安全点：指的是只在特定的位置记录下OopMap。其出现原因也就明显了，不是每个指令都生成OopMap，太占内存，只有在一些必要的位置记录，这些位置称为：**安全点（Safepoint)**。

​	也就是说，程序GC开始时不是立即停下，而是到达安全点才停下。所以安全点的选择标准：“是否具有让程序长时间执行的特征” 。这个长时间可以理解为循环、方法调用、异常跳转等。这些指令才会产生安全点。

​	另一个问题：如何在GC发生时，让所有线程都到安全点暂停（不包括JNI调用的线程），两个方法：抢占式中断、主动式中断。

​		抢占式：虚拟机让所有线程强行中断，并判断是否在安全点，没有就恢复它让其跑到安全点再暂停。少用。 		

​		主动式：虚拟机设置一个标志（和安全点位置重合、创建对象需要分配内存的地方）。线程们主动轮询，判断

​			      指令，满足则在自己挂起。

### 3、安全区域

​	安全点存在一个问题，因为线程是通过抢占机制获得CPU资源，不大可能所有线程都能获得资源跑到安全点，虚拟机也不大可能花时间去等线程获得资源，所以就存在一个安全区（Safe Region）的概念，意思是只要到了这个区域的指令，停不停都不影响对象引用，也就不影响GC。线程执行到安全区就标志自己。GC时就不用管它。线程离开Safe Region时就查一下是否完成了根节点枚举（或者整个GC过程），完成了线程就执行，否则就停。



好了，可以说说垃圾收集器了

## 三、各种垃圾收集器

### Serial 收集器

1、作用年代：默认的运行在Client模式下的默认新生代收集器。

2、特点：

​	（1）最基本、发展最久的收集器

​	（2）单线程的收集器。进行GC时需要暂停所有其他的工作线程。

3、过程：

​	**Serial和Serial Old收集器运行情况 ：**

​	（1）新生代到安全点：GC，**单线程**，采用复制算法，暂停所有线程

​	（2）老年代到安全点：GC，采用标记-整理算法，暂停所有线程

4、

​	优点：因为是单线程，可以专心处理GC，效率很高，在Client模式下的桌面程序，因为其内存不大，所以时间消耗很少。

​	缺点：Serial处理器的GC是后台运行的，并且会暂停所有线程，这意味着，在Server模式下高并发的场景带来的不可预期的线程中断是不能让人接受的，而且中断时间可能很长，不能被接受。





### ParNew 收集器

1、作用年代：新生代

2、特点：

​	（1）是Serial 的多线程版本，其他的参数配置、收集算法等和Serial的一样。

3、执行流程（ParNew/Serial Old）

​	（1）新生代**多线程**进行赋值算法的回收

4、

优点:

​	（1）除了是Serial的多线程版本之外，还是Server模式下虚拟器的首选新生代收集器。

​	（2）是除了Serial之外，能和CMS配合的一款新生代收集器。

缺点：

​	（1）和Serial一样，带来不可确定的长时的暂停。



### Parallel Scavenge收集器

1、作用年代：新生代收集器

2、特点：

​	（1）也是多线程，采用的也是复制算法，和Serial 、ParNew一致

​	（2）**“吞吐量优先”**

​		ParNew、CMS 追求的是暂停时间的短暂，而Parallel Scavege追求的是一个**可控制的吞吐量**

​		吞吐量 =  运行用户代码时间 / CPU总运行程序时间   。 

​		Parallel Scavenge收集器提供两个参数精确控制吞吐量：

​			-XX：MaxGCPauseMillis:控制最大垃圾收集停顿时间。

​				大于0ms的数，GC时JVM尽量GC时间小于此参数，但是不是越小越好，是牺牲新生代空间和吞吐量

​				换取的 。（越小回收越快，但是更容易GC）



​			-XX：GCTimeRatio：直接设置吞吐量大小

​				大于0且小于100的整数，是 垃圾收集时间占总时间的比率，相当于吞吐量的倒数。

​					

​	（3）“GC自适应的调节策略”

​		（GC Ergonomics），Parallel Scavenge收集器提供一个参数:

​		-XX:+UseAdaptiveSizePolicy 

​			打开后自动配置一些堆空间的细节，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些

​			参数已提供最合适的停顿时间或最大的吞吐量。这种调节称为GC自适应的调节策略。

​		自适应调节策略是Parallel Scavenge和ParNew的一重要区别。

​	

3、处理过程：新生代GC复制算法。

4、

​	优点：可控的吞吐量新生代收集器，适合后台运算而不需要太多交互的任务。自适应调节策略也是个优点。

​	缺点：优点即缺点。



### Serial Old收集器

1、所处年代：单线程老年代收集器。

2、特点：

​	（1）单线程老年代收集器，使用 “标记-整理”算法

​	（2）主要在Client模式下的虚拟机使用，在此模式有两种用途：	

​		· JDK1.5及之前 和 Parallel Scavenge（复制） 收集器搭配使用

​		· 作为CMS收集器的替代方案

3、处理过程：

​	在老年代单线程通过 标记-整理算法 进行GC

4、

​	优点：实现简单，Client模式下效率高（原因和Serial一样）

​	缺点：不可预估的暂停时间，在Server模式下不大高效





### Parallel Old收集器

1、特点

​	（1）Parallel Scavenge（新生代复制）的老年代版本，使用“标记-整理”，JDK1.6才提供

​	（2）其出现是为了配合 Prallel Scavenge，成为真正的吞吐量优先组合，否则只能配合只能配合Serial Old

2、处理过程

​	多线程的标记-整理GC算法

3、	

​	优点：在CPU资源敏感的场合可以优先考虑Parallel Scavenge+Parallel Old

​	

### CMS收集器

1、特点

​	（1）Concurrent Mark Sweep ，一种 **获取最短回收停顿时间**为目标的收集器，常用于B/S系统，此种注重服务器响应速度，希望系统停顿时间短，CMS非常适合。

​	（2）多线程；Mark-Sweep,**标记-清除**算法实现。

​	（3）整个处理过程最长的就在并发标记和并发清除，但是这两个过程都是可以和其他线程并发执行（即不需要stop the world），所以整体上说，CMS收集器的内存回收过程是与用户线程一起并发执行。

2、处理过程

​	初始标记（CMS initial mark）

​		· **需要stop the world**

​		· 初始标记仅标记GC Root能够关联的对象，速度快

​	并发标记（CMS concurrent mark）

​		· 对GC Roots Tracing的过程（跟踪），最耗时

​	重新标记（CMS remark）

​		· **需要stop the world**，这段停顿时间一般长于初始标记，但少于并发标记

​		· 修正并并发标记期间因程序继续运作产生的那一部分对象的标记记录

​	并发清除（CMS concurrent sweep）

​		· 也很耗时，但是不需要stop the world

3、

​	优点:

​		（1）是一款并发低停顿收集器（Concurrent Low Pause Collector），适用于B/S系统

​	缺点:

​		（1）CMS收集器对CPU资源很敏感。因为CMS收集器工作会占用一部分线程资源，导致程序变慢，总吞吐量

​			降低，默认启动线程数：（CPU数+3）/ 4	

​		（2）CMS收集器无法处理浮动垃圾（Floating Garbage）。可能出现“Concurrent Mode Failure”失败而导致另

​			一次Full GC产生。

​			浮动垃圾：当此次GC“重新标记”过程结束，开始并发清除的时候，用户程序还在运行，此时仍会产生垃

​			圾，而标记过程已经结束，这些垃圾无法在本次被清理，称为浮动垃圾。

​		（3）·由于CMS是用户程序和GC并发执行，还需要留一部分内存给老年代进行对象分配用，所以在老年代达到

​     			  一定内存大小时，导致GC。

​			· JDK1.5设置 CMS收集器当老年代使用了68％的空间被激活；JKD1.6开始，提高到98％。

​			   可以通过 -XX:CMSInitiatingOccupancyFraction值提高触发百分比。

​			· “Concurrent Mode Failure”：

​					如果CMS运行期间预留的内存无法满足程序需求，就会触发一次Concurrent Mode Failure 失

​				败，此时虚拟机采用后备方案：临时启用Serial Old（标记-整理）收集器重新进行老年代的GC，这样		

​				**停顿时间就长了** 。				

​					所以，-XX:CMSInitiatingOccupancyFraction的值不能调太高，容易导致长时停顿。

​		（4）CMS采用标记-清除，容易产生大量空间碎片。

​			为此提供一个参数：-XX:+UseCMSCompactAtFullCollection开关，默认开启，用于CMS顶不住要进行Full

​			 GC时开启内存碎片的合并整理过程。碎片没有了，暂停时间长了。

​			-XX:CMSFullGCsBeforeCompaction：设置进行多少次不压缩的Full GC后，带一次压缩合并的，默认0，	

​			即每次进行空间碎片的整理。





	### G1收集器

1、特点

​	（1）面向服务端应用的垃圾收集器，JDK1.7开始才正式商用。

​	（2）其出现是为了替代CMS（JDK1.5中），相比之下有以下特点：

​		· 并发和并行：G1充分利用多核CPU的优势实现多线程，使垃圾回收线程和用户线程能同时并行运行。

​		· 分代收集：CMS只能用于老年代；G1可以不需要配合其他收集器就能独立管理整个GC堆。

​		· 空间整合：CMS是标记-清除，而G1整体上是标记-整理。局部上G1的空间清理划分是一个个Region，每个

​				    Region采用复制算法，这两种算法都不会产生空间碎片。	

​		· 可预测的停顿

​	  （3）关于可预测的停顿：

​			G1垃圾回收器保留了新生代、老年代的概念，但是在空间上划分为一个个等大的Region，新生代和老年代

​		只是逻辑上的隔离。G1的核心思想就是避免对整个堆进行全区域的垃圾回收。G1通过计算每个Region的回收价

​		值，维护一个**优先列表**，根据用户允许的回收时间，优先回收价值最大的Region。保证G1在有限时间内尽可能

​		高效地提高回收效率。



​		**Rmember Set** : 

​			存在问题：一个对象不大可能只引用本Region的其他对象或者可被其他Region的对象引用，这样又需要

​		扫描整个堆，看看谁引用了这个Region的对象，为此，提出：**Remember Set （属于Region）**

​			Remember Set 避免虚拟机全堆扫描，当虚拟机发现程序对Reference类型的数据进行写操作时，产生一个

​		写障碍（Write Barrier）暂停写操作，然后检查Reference引用的对象是否处于不同的Region中，若是，则通过

​		CardTable把相关引用信息记录到被引用对象所属的Region的Rmember Set 中。当GC时，在需要的时候只需要

​		再枚举Remember Set 即可保证不对整个堆进行扫描。				

​			

2、处理过程 （和CMS差不多，四个过程）

​	初始标记 ：查找GC Roots能直接关联的对象，需要stop the world，但是耗时短。

​	并发标记：从GC Roots进行可达性分析，寻找存活的对象，这阶段耗时较长，但可与用户线程并发运行

​	最终标记：为了修正在并发标记期间因用户程序继续运行导致标记变动的那部分标记记录，此部分记录放在

​			  Remember Set Logs中，最终会合并到Remember Set中，**需要 停顿 线程，但是可并行执行。**

​	筛选回收：先对各个Region的回收价值、成本排序，然后按用户期望的GC停顿时间来指定回收计划，可以和用户线

​			  程并发执行。



3、

​	优点：

​		· 不会产生空间碎片（整体标记-整理）

​		· 可预测的GC停顿

​		· 较短的停顿时间









