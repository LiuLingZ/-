# 垃圾回收算法

垃圾回收的内容

有哪几种

各自特点、优缺点



## 一、垃圾回收内容

​	当对象死亡，则可以在GC时进行回收。

### 1、判断对象是否死亡 （3种方法）

（1）引用计数法

​	特点：给对象一个引用计数器，一个地方引用它，则数目+1；引用失效时，数目-1	

​	优点：实现简单，逻辑比较简单。

​	缺点：存在循环引用的问题。

（2）可达性算法分析

​	特点：

​			通过一系列“GC Roots”对象作为起点，从这些起点向下搜索，这个搜索称为“引用链”，凡其中一个GC Root

​		能引	用到的对象都是存活的，没有一个GC Root引用到的都是可以被回收的对象。

​			可以作为GC Root的对象：

​				a. 虚拟机栈中引用的对象

​				b. 方法区中静态属性引用的对象

​				c. 方法区中常量引用的对象

​				d. 本地方法栈中JNI（即Native方法）引用的对象

​	

### 2、对象的存活与否和“引用”有关

​	虚拟机中的对象引用有四种类型，其作用是为了满足"当内存足够时，不回收；当内存经过GC后还是很紧张，就回收这些对象"。这四种引用类型由强到弱，依次是：**强引用、软引用、弱引用、虚引用**

​	**强引用**

​		类似直接new出来的对象，只要还存活，就不会被GC回收。

​	**软引用**

​		指 "还有但是非必须" 。当内存要OOM的时候，对其进行GC回收，如果GC后空间够，就不会OOM；如果还不够，才会OOM。JDK1.2后提供 SoftReference类实现软引用。

​	**弱引用**

​		指 "非必须" 对象，强度比软引用弱些。被引用的对象只能存活到下一次GC发生之前，即，GC时，不论内存空间是否足够，都要回收弱引用引用的对象。WeakReference实现弱引用。

​	**虚引用**

​		"幽灵引用"、"幻影引用"。最弱的引用。一个对象的是否有无虚引用都不会影响其生存情况；无法通过虚引用引用到对象；唯一目的：虚引用对象被收集器回收时收到一个系统通知（即被回收就提醒一下系统）。 PhantomReference类实现。

​	



## 二、垃圾回收算法种类

​	一共有四种垃圾回收算法：

###1、标记-清除算法

​	特点：

​		Mark-Sweep，分两个阶段：标记、清除。过程：①、首先进行对象存活判断（用到了前面说的"引用计数法"或者"可达性分析"），标记已经可以被回收的对象。②、对标记的对象内存空间进行回收。

​	优点：实现简单。

​	缺点：①、一个是效率问题，标记、清除效率均不高（都是挨个找，还得一个个快判断是否被标记）。②、第二个是空间问题。因为是直接回收已经被标记的对象的内存，所以容易产生大量的内存空间碎片，在后续分配连续大空间的对象时可能提前导致GC。

### 2、复制算法

​	特点：为了解决效率问题，不要在清除的时候还得一个个判断，就产生了复制算法。思想如下：空间划分为1:1的两个部分，每次分配只在一个部分中，当这个部分的内存用完时，就将还存活的对象复制到另外一个部分中，然后直接对这一个部分进行内存回收，这样就不用判断内存块中哪些可以回收，直接全部回收。并且也不会产生内存碎片。

​	优点：实现简单，高效，不会产生内存碎片。

​	缺点：代价太高，一次就只能用一半的内存空间。	

### 3、标记-整理算法

​	特点：复制算法在对象存活率较高的情况效率低。而且要浪费50％的空间。所以老年代不使用复制算法。标记-整理和标记清除在标记阶段都是一样的，但是标记后不是清除，而是将存活对象往内存的一端移动，即存活的全部放到一边去，清除其余的内存部分。

​	优点：不会有内存碎片

​	缺点：效率也比较低。	

### 4、分代收集算法

​	特点：

​	为了减少复制算法的代价，对堆空间的划分为新生代、老年代=1:2，再将新生代划分为Eden、From Survivor、To Survivor = 8:1:1 。 在新生代使用 标记-整理算法（老年代不使用是因为老年代是最后的存储空间，不能再浪费空间了，并且老年代的GC不频繁，都是多次GC后活下来的对象。）但是不是1:1的保留空间，而是8:1:1，在新生代选择10分之1（其中一个survivor区）进行保留空间，然后实现复制算法。每次分配对象在 一个Eden 和 一个Survivor中，然后另外一个Survivor进行空间的担保。

​	优点：效率比较高，不会产生空间碎片

​	缺点：有一部分内存会被浪费。





## 三、常用的内存调试工具

### 1、jmap

​		JVM Memory Map命令用于生成heap dump文件，如果不使用这个命令，还可以使用	

​	XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候自动生成dump文件。 jmap不仅能生成dump

​	文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。

### 2、jstack

​		jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的

​	Java堆栈信息 。

### 3、jconsole

​		Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对

​	运行’在java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务

​	器内存很小，甚至可以说几乎不消耗。

### 4、jstat

​	JVM Statistics Monitoring Tool，是用于监视虚拟机各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中类装载、内存、垃圾收集、JIT编译等运行数据。

### 5、jps

​		JVM Process Status Tool，功能是列出正在运行的虚拟机进程，并显示虚拟机执行主类名称以及这些进程在本

​	地虚拟机唯一ID。

​	

### 6、jhat

​		JVM Heap Analysis Tool，和jmap搭配使用，来分析jmap的堆转存快照。





​	

​		

