# 垃圾回收算法

垃圾回收的内容

有哪几种

各自特点、优缺点



## 一、垃圾回收内容

​	当对象死亡，则可以在GC时进行回收。

### 1、判断对象是否死亡 （3种方法）

（1）引用计数法

​	特点：给对象一个引用计数器，一个地方引用它，则数目+1；引用失效时，数目-1	

​	优点：实现简单，逻辑比较简单。

​	缺点：存在循环引用的问题。

（2）可达性算法分析

​	特点：

​			通过一系列“GC Roots”对象作为起点，从这些起点向下搜索，这个搜索称为“引用链”，凡其中一个GC Root

​		能引	用到的对象都是存活的，没有一个GC Root引用到的都是可以被回收的对象。

​			可以作为GC Root的对象：

​				a. 虚拟机栈中引用的对象

​				b. 方法区中静态属性引用的对象

​				c. 方法区中常量引用的对象

​				d. 本地方法栈中JNI（即Native方法）引用的对象

​	

### 2、对象的存活与否和“引用”有关

​	虚拟机中的对象引用有四种类型，其作用是为了满足"当内存足够时，不回收；当内存经过GC后还是很紧张，就回收这些对象"。这四种引用类型由强到弱，依次是：**强引用、软引用、弱引用、虚引用**

​	**强引用**

​		类似直接new出来的对象，只要还存活，就不会被GC回收。

​	**软引用**

​		指 "还有但是非必须" 。当内存要OOM的时候，对其进行GC回收，如果GC后空间够，就不会OOM；如果还不够，才会OOM。JDK1.2后提供 SoftReference类实现软引用。

​	**弱引用**

​		指 "非必须" 对象，强度比软引用弱些。被引用的对象只能存活到下一次GC发生之前，即，GC时，不论内存空间是否足够，都要回收弱引用引用的对象。WeakReference实现弱引用。

​	**虚引用**

​		"幽灵引用"、"幻影引用"。最弱的引用。一个对象的是否有无虚引用都不会影响其生存情况；无法通过虚引用引用到对象；唯一目的：虚引用对象被收集器回收时收到一个系统通知（即被回收就提醒一下系统）。 PhantomReference类实现。

​	



## 二、垃圾回收算法种类

​	一共有四种垃圾回收算法：

###1、标记-清除算法

​	特点：

​		Mark-Sweep，分两个阶段：标记、清除。过程：①、首先进行对象存活判断（用到了前面说的"引用计数法"或者"可达性分析"），标记已经可以被回收的对象。②、对标记的对象内存空间进行回收。

​	优点：实现简单。

​	缺点：①、一个是效率问题，标记、清除效率均不高（都是挨个找，还得一个个快判断是否被标记）。②、第二个是空间问题。因为是直接回收已经被标记的对象的内存，所以容易产生大量的内存空间碎片，在后续分配连续大空间的对象时可能提前导致GC。

### 2、复制算法

​	特点：为了解决效率问题，不要在清除的时候还得一个个判断，就产生了复制算法。思想如下：空间划分为1:1的两个部分，每次分配只在一个部分中，当这个部分的内存用完时，就将还存活的对象复制到另外一个部分中，然后直接对这一个部分进行内存回收，这样就不用判断内存块中哪些可以回收，直接全部回收。并且也不会产生内存碎片。

​	优点：实现简单，高效，不会产生内存碎片。

​	缺点：代价太高，一次就只能用一半的内存空间。	

### 3、标记-整理算法

​	特点：复制算法在对象存活率较高的情况效率低。而且要浪费50％的空间。所以老年代不使用复制算法。标记-整理和标记清除在标记阶段都是一样的，但是标记后不是清除，而是将存活对象往内存的一端移动，即存活的全部放到一边去，清除其余的内存部分。

​	优点：不会有内存碎片

​	缺点：效率也比较低。	

### 4、分代收集算法

​	特点：

​	为了减少复制算法的代价，对堆空间的划分为新生代、老年代=1:2，再将新生代划分为Eden、From Survivor、To Survivor = 8:1:1 。 在新生代使用 标记-整理算法（老年代不使用是因为老年代是最后的存储空间，不能再浪费空间了，并且老年代的GC不频繁，都是多次GC后活下来的对象。）但是不是1:1的保留空间，而是8:1:1，在新生代选择10分之1（其中一个survivor区）进行保留空间，然后实现复制算法。每次分配对象在 一个Eden 和 一个Survivor中，然后另外一个Survivor进行空间的担保。

​	优点：效率比较高，不会产生空间碎片

​	缺点：有一部分内存会被浪费。

​		

