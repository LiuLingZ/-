https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ

# JMM

​	Java Memory Model,Java内存模型

## 1、引入

​	JVM定义的，屏蔽掉各种硬件和操作系统的内存访问差异，实现让Java程序在各个平台都能达到一致的内存访问效果。JMM主要目标是**定义程序中各个变量的访问规则。也即制定多个线程对主存中共享变量修改、同步规则 。** 

（ps : 这里的变量指的是：实例字段、静态字段、构成数组对象的元素，不包括局部变量，因为后者为线程私有）

​	**JMM为了保证多线程并发过程共享内存的正确性（并发正确：可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作的规范。**







## 2、模型

![img](https://mmbiz.qpic.cn/mmbiz_png/3yib6PA74333DxU098TQ2CSOg7z6qNc4E7wNAftiaZ0rJaKImyfyIdiaexLnoSJ7lyJbicEdOq0Vj4tWuohaSl8KFw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 解释

```
- JMM规定，线程不允许直接操作主内存中变量的值，必须先拷贝到自己的工作内存，再进行操作，最后同步回主内存中
- 工作内存保存的是主内存中变量的拷贝，并不是真的整个拷贝，而是对需要使用的部分的拷贝，不是整个！
- volatile也是对线程的拷贝，只是根据其特殊的操作顺序规定，能够实现可见性。
- 各个线程的工作内存是隔离的，无法相互操作。
- JMM定义8个操作完成主内存和工作内存间的交互操作，8个操作都是原子性的
```



### 8个操作

**（均是原子性的）**

![img](https://mmbiz.qpic.cn/mmbiz_png/3yib6PA74333DxU098TQ2CSOg7z6qNc4E8sWbYkl4XRplvhMfiagfxibEPq6DZrZF7HMZNPESuxwxib74EibywTSWCw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- **read**(读取)：作用于**主内存**的变量，把一个变量的值从**主内存**传输到**工作内存**中。
- **load**(载入)：作用于**工作内存**的变量，把 **read** 得到的值放入**工作内存**的变量副本中。
- **use**(使用)：作用于**工作内存**的变量，把工作内存中一个变量的值传递给执行引擎。
- **assign**(赋值)：作用于**工作内存**的变量，把一个从执行引擎接收到的值赋给**工作内存**的变量。
- **store**(存储)：作用于**工作内存**的变量，把**工作内存**的一个变量的值传送到**主内存**中。
- **write**(写入)：作用于**主内存**的变量，把 **store** 得到的值放入**主内存**的变量中。
- **lock**(锁定)：作用于**主内存**的变量，它把一个变量标识为一条线程独占的状态。
- **unlock**(解锁)：作用于**主内存**的变量，它取消变量标识为一条线程独占的状态。





# Volatile

​	volatile 能够满足并发安全的两个特性： 可见性  和 有序性

## 1、可见性

- 并不是对volatile变量的更新能立刻被主存所见，而是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新 。 （**用时更新、立刻刷新**）



## 2、有序性

- volatile 可以禁止指令重排序优化

  ```
  为什么出现指令重排：
  	指令重排是机器级的优化操作，对一些不相干的语句，为了充分利用到处理器的资源，在不影响结果的情况下将 	  后续的指令先执行。
  ```

- volatile通过内存屏障解决指令重排序

  ```
  指令重排序不能越过内存屏障（JDK1.5才完全修复好。）
  ```



### 内存屏障

- Memory Barrier 或 Memory Fence , 重排序不能把后面的命令放到内存屏障之前执行。

- **内存屏障是执行了一条lock前缀的CPU的缓存写入主存的一条空语句，能够无效化其他CPU的缓存，让他们重新读取**

  **因为指令重排序不能越过更新语句，所以间接实现了不能越过内存屏障。**

- 有了内存屏障，读速度差不多，写速度稍微慢一点，无伤大雅。



## 3、原子性

​	volatile不能满足原子性，类似 i++ 的操作需要原子性约束



# 先行发生原则

​	在这几种情况下，默认是有序的，不会发生乱序执行，除了synchronized 和 volatile之外 能保证有序性



###程序次序规则

​	单线程中，程序执行结果 和 代码顺序执行结果是一样的

### 管程锁定规则

​	对于同一个共享变量，对其加锁，上一个加锁的unlock必须要在 下一个加锁的lock执行

### volatile变量规则

​	多个线程对volatile修饰的变量的同一时刻的操作，写操作先于读操作

### 线程启动规则

​	线程的start() 先于线程执行体的任何代码的执行

### 线程终止规则

​	对线程执行体的所有操作先于对线程的终止检查，比如A线程调用B.join ，这个join就会慢与代码的执行

### 线程中断规则

​	对线程的interrupt()调用先于对线程中断检查，比如调用 interrupted() 

### 对象终结规则

​	对象的初始化（即《clinit()》）先于finalize()方法的开始

### 传递性

​	A先于B，B先于C，则A先于C