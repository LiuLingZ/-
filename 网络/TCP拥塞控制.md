推荐视频链接：https://www.bilibili.com/video/av52266048?from=search&seid=17329230343218068857

# 拥塞控制



## 一、两种层面的拥塞控制

​	拥塞控制有两个层面，一个是端到端的拥塞控制，也是常说的拥塞控制； 另一个是网络辅助的拥塞控制，这里需要其他设备帮忙维护监控。



### 端到端的拥塞控制

```
在这个方法中，网络层没有为运输层拥塞控制提供显示支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察（如分组丢失与时延）来推断。TCP必须通过端到端的方法来解决也拥塞控制，因为IP层不会向端系统提供有关网络拥塞的反馈信息。TCP报文段的丢失（通过超时或3次冗余确认得知）被认为是网络出现拥塞的一个迹象，TCP会相应地减小其窗口长度。在TCP拥塞控制的一些最新建议也会使用增加的往返时延值作为网络拥塞程度增加的指示。
```



### 网络辅助的拥塞控制

```
在网络辅助的拥塞控制中，网络层构件（即路由器）向发送方提供有关网络中拥塞状态的显示反馈信息。
拥塞信息从网络反馈到发送方通常有两种方式：①直接反馈信息由网络路由器发给发送方，这种通知方式常采用了一种阻塞分组（choke packet）的形式（含义为：“我阻塞了”）②显示拥塞通知（Explicit Congestion Notification,ECN）。第二种是路由器标记或更新熊发送方流向接收方的分组中的某个字段来指示拥塞的产生。当接收方接收到这样的分组后，就会向发送方发送网络拥塞的通知。这种方式需要至少需要一个完整的RTT。使用网络辅助的拥塞控制例子可参见ATM ABR拥塞控制。
```



**下面均常用的端到端的拥塞控制为主要讲解。**



## 二、端到端的拥塞控制

### 1、概念

​	某段时间，对网络中某一资源的需求超过资源所能提供的可用部分，网络性能就变差，这种情况就叫拥塞。

​	（在网络中，资源包含链路容量（带宽）、交换节点中的缓存和处理机等。）

​	如果出现拥塞而不控制，整个网络的吞吐量将会随着负荷增大而下降。

​	PS：TCP的流量控制是端到端之间的，仅限于通信的两台主机，而拥塞控制是整个网络的，涉及网络中的所有主机。



### 2、TCP四种拥塞控制算法

​	慢开始（slow-start）

​	拥塞避免（congestion avoidance）

​	快重传(fast retransmit)

​	快恢复(fast recovery)



**--------------------下面介绍的思路从出现、优化开始，即原本的拥塞控制和优化后的拥塞控制。------------------------**		

### 3、过程

##### i、几个概念

```
拥塞窗口cwnd ：
	发送端维护的一个状态变量，这个值由网络的拥塞程度决定，是动态变化的。
	cwnd的维护原则：没有出现拥塞，拥塞窗口cwnd就会再增大一些，而出现拥塞，窗口就减小一些。
	判断网络是否拥塞依据：是否没有按时收到应达到的确认报文（即发生重传）。
	
发送窗口swnd ：
	发送窗口数值就是实际发送报文段的数值，一般都会让 swnd = cwnd 。
	
慢开始门限ssthresh变量：
	这是分隔慢开始和拥塞避免算法的一个变量值：
	当 cwnd < ssthresh 时，即swnd发送的报文段数目小于 ssthresh，使用慢开始算法 发送；
	当 cwnd > ssthresh 时，即swnd发送的报文段数目大于 ssthresh，使用拥塞避免算法 发送。
	cwnd = ssthresh 时，既可以慢开始，也可以使用拥塞避免算法。
```

##### ii、原始过程

```
1、刚开始，设置慢开始门限为16，这代表cwnd<=16时，使用慢开始算法。此时swnd=cwnd=1,ssthresh=16.开始传输。
2、
    刚开始，发送一个报文，收到一个响应，代表没有拥塞，接着，cwnd = 2*cwnd = 2 ，swnd=cwnd=2，开始发送2个报文，收到两个响应，也没有阻塞；接着，cwnd = 2*cwnd = 4, swnd = cwnd = 4 ,发送4个报文，得到四个响应， 也没有问题，接着就 cwnd=2*cwnd = 8,收到8个响应，没问题；cwnd = 2*cwnd = 16，发送16个，收到响应，也没问题。
（上面这个过程就是慢开始。）

3、当cwnd=16=ssthresh是，接下来就开始 拥塞避免算法：
	接下来不是指数增长式地增加发送的报文数量，而是每次+1 ：cwnd = cwnd+1 ; swnd = cwnd = 17 ；
这次发送17个数据包，接收到17个响应，代表没有拥塞。依次类推，一直+1 。

4、
	假设，现在 cwnd = swnd = 24个数据包，然后接收响应的时候，少了4个包，这时候，就代表认为已经发生拥塞了，那么这个时候，几个变量的值就变化了；
	首先，慢开始门限 ssthresh = 24/2 = 12 ，即变为最高值传输报文数的一般 ；
	然后，设置 cwnd = swnd = 1 ,即重新 慢开始，从1个包开始慢开始算法发送 ;
	接下来的慢开始发送，直到 cwnd = swnd = 12时，再开始进行拥塞避免算法发送报文。
	
这样，就趋于稳定，原始的拥塞控制 认为 网络拥塞 的证据 就是 响应丢失或者响应超时。一旦出现，马上退回最原始状态，再重新尝试发送数据包的过程。


```

**要点：**

- “慢开始” 的 慢，指的是一开始注入到网络中的数据包数量少，并不是拥塞窗口速度增长得慢。
- “拥塞避免” 不能够完全避免拥塞，只是其发包数目的增长是线性的，降低出现拥塞的可能性。（慢慢尝试，不会一下子突然发很多包）

- 这是原本的TCP拥塞控制算法，指包含了 慢开始 和 拥塞避免。这种缺点比较明显，即丢包并不一定是网络阻塞，可能超时；而且原本一旦判定为”拥塞“，就得重新慢开始发送，效率较低。为此，提出了改进：**快重传** 和 **快恢复**。



### iii、改进过程

```
1、上述三步相同，都是先慢开始，再到拥塞避免算法。但是有个不同的地方
- 即：不再是发一个响应一个，而是发送方一直发，接收方收到一个响应一个，即使未收到响应，发送方仍可继续发送。
- 基于这种交互方式，也是为快重传、快回复做支持。
- eg ：A为发送，B为接收； A发送1 2 3 ，B响应1 2 3。

2、假设现在A发送1 2 3，B接收并响应了1 2，但是没有3，代表B没收到3，B就会响应2回去，是响应2；（第一次响应）
   A收到后，记下，接着发送5，B收到5，但是仍响应2；（第二次响应）
   A收到记下，接着发送6，B收到，仍然响应2，因为没收到3,；（第三次响应）
   
   经过三次响应，A就知道B没有收到3，就会重传3过去，B收到后，就会整合刚才收到的，刚刚收到的最后是6，现在3齐了，1-6都收到了，此时B就响应 6 回去，代表1-6B都收到了，A接收到后，就明白B全部接受了。
   
   上述2步骤就是 “快重传” ，经历三次响应后立刻传回丢失的报文段。
   
 3、当然2步骤除了做“快重传”之外，还做了“快恢复” ：
 	在这里，让 慢开始门限变为 拥塞窗口cwnd（max）的一般，假设原来出现三次响应的时候cwnd=16，那么此时，
 慢开始门限 ssthresh = cwnd / 2 = 8 ;
 	这时候，不会让 cwnd = swnd = 1，而是让他们等于慢开始门限的值，即 cwnd = swnd = 8，然后直接进行拥塞避免算法。
 	
 	
这就是优化后的TCP拥塞控制，从刚开始的 慢开始、拥塞避免 -> 慢开始、拥塞避免、快恢复、快重传。
   

```



















































